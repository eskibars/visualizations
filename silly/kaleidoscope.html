<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8"/>
  <meta name="viewport" content="width=device-width,initial-scale=1"/>
  <title>Kaleidoscope</title>
  <style>
    html,body{ margin:0; height:100%; overflow:hidden; background:#050508; }
    canvas{ display:block; width:100vw; height:100vh; }
    .vignette{
      pointer-events:none; position:fixed; inset:0;
      background: radial-gradient(circle at 50% 50%,
        rgba(0,0,0,0) 25%, rgba(0,0,0,0.35) 70%, rgba(0,0,0,0.75) 100%);
    }
  </style>
</head>
<body>
  <canvas id="c"></canvas>
  <div class="vignette"></div>
<script>
(() => {
  // -------------------- Config --------------------
  const CFG = {
    dprCap: 2,
    segments: 12,          // number of mirror slices
    holdTime: 10.0,        // seconds to hold each pattern
    transitionTime: 1.5,   // seconds for crossfade
    rotationSpeed: 0.15,   // radians/sec while animating
    shapesPerPattern: 18,  // random shapes in source wedge
  };

  const canvas = document.getElementById('c');
  const ctx = canvas.getContext('2d');
  let W = 0, H = 0, DPR = 1, R = 0; // R = kaleidoscope radius

  // -------------------- Utilities --------------------
  function rand(a, b) { return a + Math.random() * (b - a); }
  function clamp(v, a, b) { return Math.max(a, Math.min(b, v)); }
  function lerp(a, b, t) { return a + (b - a) * t; }

  // -------------------- Offscreen pattern canvases --------------------
  let patternA = null; // current pattern (offscreen canvas)
  let patternB = null; // next pattern (offscreen canvas)

  function createOffscreen(size) {
    const c = document.createElement('canvas');
    c.width = size;
    c.height = size;
    return c;
  }

  // -------------------- Random palette --------------------
  function randomPalette() {
    // Generate a harmonious set of 4-6 colors using a random base hue
    const baseHue = rand(0, 360);
    const count = (rand(4, 7) | 0);
    const colors = [];
    for (let i = 0; i < count; i++) {
      const h = (baseHue + i * rand(25, 75)) % 360;
      const s = rand(55, 95);
      const l = rand(35, 75);
      const a = rand(0.5, 1.0);
      colors.push(`hsla(${h}, ${s}%, ${l}%, ${a})`);
    }
    return colors;
  }

  // -------------------- Generate random pattern in a wedge --------------------
  function generatePattern(size) {
    const offscreen = createOffscreen(size);
    const oc = offscreen.getContext('2d');
    const palette = randomPalette();
    const pick = () => palette[(Math.random() * palette.length) | 0];
    const wedgeAngle = Math.PI / CFG.segments;

    // Transparent background (shapes only)
    oc.clearRect(0, 0, size, size);

    // Draw into a wedge from center
    const cx = size / 2;
    const cy = size / 2;
    const maxR = size / 2;

    oc.save();
    oc.translate(cx, cy);

    // Clip to wedge shape for clean edges
    oc.beginPath();
    oc.moveTo(0, 0);
    oc.arc(0, 0, maxR, -wedgeAngle, wedgeAngle);
    oc.closePath();
    oc.clip();

    // Random shapes
    for (let i = 0; i < CFG.shapesPerPattern; i++) {
      const shapeType = Math.random();
      oc.save();

      if (shapeType < 0.3) {
        // Filled circle
        const r = rand(maxR * 0.03, maxR * 0.25);
        const dist = rand(maxR * 0.05, maxR * 0.85);
        const angle = rand(-wedgeAngle * 0.9, wedgeAngle * 0.9);
        const x = Math.cos(angle) * dist;
        const y = Math.sin(angle) * dist;

        const grad = oc.createRadialGradient(x, y, 0, x, y, r);
        grad.addColorStop(0, pick());
        grad.addColorStop(1, pick());
        oc.fillStyle = grad;
        oc.beginPath();
        oc.arc(x, y, r, 0, Math.PI * 2);
        oc.fill();

      } else if (shapeType < 0.55) {
        // Arc / ring
        const dist = rand(maxR * 0.1, maxR * 0.7);
        const r = rand(maxR * 0.08, maxR * 0.35);
        const startA = rand(-wedgeAngle, wedgeAngle * 0.5);
        const endA = startA + rand(0.3, Math.PI);
        oc.strokeStyle = pick();
        oc.lineWidth = rand(2, 8);
        oc.lineCap = 'round';
        oc.beginPath();
        oc.arc(0, 0, dist, startA, endA);
        oc.stroke();

      } else if (shapeType < 0.75) {
        // Bezier curve
        const d1 = rand(maxR * 0.1, maxR * 0.8);
        const a1 = rand(-wedgeAngle * 0.8, wedgeAngle * 0.8);
        const d2 = rand(maxR * 0.1, maxR * 0.8);
        const a2 = rand(-wedgeAngle * 0.8, wedgeAngle * 0.8);
        const cp1d = rand(maxR * 0.1, maxR * 0.6);
        const cp1a = rand(-wedgeAngle, wedgeAngle);
        const cp2d = rand(maxR * 0.1, maxR * 0.6);
        const cp2a = rand(-wedgeAngle, wedgeAngle);

        oc.strokeStyle = pick();
        oc.lineWidth = rand(1.5, 6);
        oc.lineCap = 'round';
        oc.beginPath();
        oc.moveTo(Math.cos(a1) * d1, Math.sin(a1) * d1);
        oc.bezierCurveTo(
          Math.cos(cp1a) * cp1d, Math.sin(cp1a) * cp1d,
          Math.cos(cp2a) * cp2d, Math.sin(cp2a) * cp2d,
          Math.cos(a2) * d2, Math.sin(a2) * d2
        );
        oc.stroke();

      } else if (shapeType < 0.88) {
        // Diamond / polygon
        const dist = rand(maxR * 0.15, maxR * 0.7);
        const angle = rand(-wedgeAngle * 0.7, wedgeAngle * 0.7);
        const sz = rand(maxR * 0.04, maxR * 0.15);
        const sides = (rand(3, 7) | 0);
        const rot = rand(0, Math.PI * 2);

        oc.fillStyle = pick();
        oc.beginPath();
        for (let s = 0; s < sides; s++) {
          const sa = rot + (s / sides) * Math.PI * 2;
          const px = Math.cos(angle) * dist + Math.cos(sa) * sz;
          const py = Math.sin(angle) * dist + Math.sin(sa) * sz;
          if (s === 0) oc.moveTo(px, py);
          else oc.lineTo(px, py);
        }
        oc.closePath();
        oc.fill();

      } else {
        // Radial line from center
        const a1 = rand(-wedgeAngle * 0.9, wedgeAngle * 0.9);
        const d1 = rand(maxR * 0.05, maxR * 0.3);
        const d2 = rand(maxR * 0.4, maxR * 0.9);

        oc.strokeStyle = pick();
        oc.lineWidth = rand(1, 5);
        oc.lineCap = 'round';
        oc.beginPath();
        oc.moveTo(Math.cos(a1) * d1, Math.sin(a1) * d1);
        oc.lineTo(Math.cos(a1) * d2, Math.sin(a1) * d2);
        oc.stroke();
      }

      oc.restore();
    }

    oc.restore();
    return offscreen;
  }

  // -------------------- Draw kaleidoscope from a pattern --------------------
  function drawKaleidoscope(pattern, rotation, alpha) {
    if (!pattern) return;
    const cx = W / 2;
    const cy = H / 2;
    const sliceAngle = (Math.PI * 2) / CFG.segments;

    ctx.save();
    ctx.globalAlpha = alpha;
    ctx.translate(cx, cy);
    ctx.rotate(rotation);

    for (let i = 0; i < CFG.segments; i++) {
      ctx.save();
      ctx.rotate(i * sliceAngle);

      // Alternate: normal and mirrored (reflection)
      if (i % 2 === 1) {
        ctx.scale(1, -1);
      }

      // Draw the pattern centered
      ctx.drawImage(pattern, -pattern.width / 2, -pattern.height / 2);
      ctx.restore();
    }

    ctx.restore();
  }

  // -------------------- State machine --------------------
  const STATE = { ROTATING: 0, HOLDING: 1, TRANSITIONING: 2 };
  let state = STATE.HOLDING;
  let stateTimer = 0;
  let rotation = 0;
  let targetRotation = 0; // snap rotation target

  function nextPattern() {
    patternA = patternB || generatePattern(Math.floor(R * 2));
    patternB = generatePattern(Math.floor(R * 2));
  }

  // -------------------- Resize --------------------
  function resize() {
    DPR = Math.min(CFG.dprCap, window.devicePixelRatio || 1);
    W = Math.floor(window.innerWidth);
    H = Math.floor(window.innerHeight);
    canvas.width = Math.floor(W * DPR);
    canvas.height = Math.floor(H * DPR);
    ctx.setTransform(DPR, 0, 0, DPR, 0, 0);
    R = Math.min(W, H) * 0.48;

    // Regenerate patterns at new size
    patternA = generatePattern(Math.floor(R * 2));
    patternB = generatePattern(Math.floor(R * 2));
    state = STATE.HOLDING;
    stateTimer = 0;
  }
  window.addEventListener('resize', resize, { passive: true });

  // -------------------- Easing --------------------
  function easeInOutCubic(t) {
    return t < 0.5 ? 4 * t * t * t : 1 - Math.pow(-2 * t + 2, 3) / 2;
  }

  // -------------------- Grain --------------------
  let noisePattern;
  function buildNoise() {
    const tile = document.createElement('canvas');
    const s = 180;
    tile.width = s; tile.height = s;
    const nc = tile.getContext('2d');
    const img = nc.createImageData(s, s);
    const d = img.data;
    for (let i = 0; i < d.length; i += 4) {
      const v = (Math.random() * 255) | 0;
      d[i] = v; d[i+1] = v; d[i+2] = v;
      d[i+3] = (Math.random() * 25) | 0;
    }
    nc.putImageData(img, 0, 0);
    noisePattern = ctx.createPattern(tile, 'repeat');
  }

  // -------------------- Main loop --------------------
  let last = performance.now();
  const sliceAngle = (Math.PI * 2) / CFG.segments;

  function frame(now) {
    const dt = Math.min(0.05, (now - last) / 1000);
    last = now;
    const time = now / 1000;

    // Black background
    ctx.fillStyle = '#050508';
    ctx.fillRect(0, 0, W, H);

    // State machine
    stateTimer += dt;

    switch (state) {
      case STATE.HOLDING:
        // Show current pattern, held still
        if (stateTimer >= CFG.holdTime) {
          state = STATE.TRANSITIONING;
          stateTimer = 0;
        }
        drawKaleidoscope(patternA, rotation, 1);
        break;

      case STATE.TRANSITIONING: {
        // Crossfade from patternA to patternB while rotating
        const progress = clamp(stateTimer / CFG.transitionTime, 0, 1);
        const eased = easeInOutCubic(progress);

        // Rotate during transition
        rotation += CFG.rotationSpeed * dt * 3;

        // Draw old fading out, new fading in
        drawKaleidoscope(patternA, rotation, 1 - eased);
        drawKaleidoscope(patternB, rotation, eased);

        if (progress >= 1) {
          nextPattern();
          state = STATE.HOLDING;
          stateTimer = 0;
        }
        break;
      }
    }

    // Subtle slow continuous rotation even during hold
    if (state === STATE.HOLDING) {
      rotation += CFG.rotationSpeed * dt * 0.3;
    }

    // Subtle center glow
    ctx.save();
    ctx.globalCompositeOperation = 'screen';
    ctx.globalAlpha = 0.08;
    const glow = ctx.createRadialGradient(W/2, H/2, 0, W/2, H/2, R * 0.4);
    glow.addColorStop(0, 'rgba(255, 255, 255, 0.5)');
    glow.addColorStop(1, 'rgba(255, 255, 255, 0)');
    ctx.fillStyle = glow;
    ctx.beginPath();
    ctx.arc(W/2, H/2, R * 0.4, 0, Math.PI * 2);
    ctx.fill();
    ctx.restore();

    // Grain
    if (noisePattern) {
      ctx.save();
      ctx.globalCompositeOperation = 'overlay';
      ctx.globalAlpha = 0.04;
      ctx.translate(Math.sin(time * 0.7) * 30, Math.cos(time * 0.5) * 30);
      ctx.fillStyle = noisePattern;
      ctx.fillRect(-40, -40, W + 80, H + 80);
      ctx.restore();
    }

    requestAnimationFrame(frame);
  }

  resize();
  buildNoise();
  requestAnimationFrame(frame);
})();
</script>
</body>
</html>
