<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>CRT Terminal</title>
  <style>
    :root{
      --bg: #030805;
      --phosphor: #49ff8a;
      --phosphor-dim: rgba(73,255,138,.18);
      --phosphor-dimmer: rgba(73,255,138,.08);
      --glow: rgba(73,255,138,.35);
      --edge: rgba(0,0,0,.75);
      --scanlineA: rgba(0,0,0,.20);
      --scanlineB: rgba(0,0,0,.05);
    }

    html, body {
      height: 100%;
      margin: 0;
      background: #000;
      overflow: hidden;
      font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
    }

    /* CRT frame */
    .crt {
      position: relative;
      height: 100%;
      width: 100%;
      background: radial-gradient(1200px 700px at 50% 45%,
        rgba(15,35,22,.65) 0%,
        rgba(5,12,8,.85) 55%,
        rgba(0,0,0,1) 100%);
      display: grid;
      place-items: center;
    }

    .screen {
      position: relative;
      width: min(1400px, 92vw);
      height: min(820px, 92vh);
      background: linear-gradient(180deg, rgba(2,6,4,.95), rgba(2,6,4,.98));
      border-radius: 22px;
      box-shadow:
        0 20px 80px rgba(0,0,0,.85),
        0 0 0 2px rgba(255,255,255,.03) inset,
        0 0 0 1px rgba(73,255,138,.05),
        0 0 60px rgba(73,255,138,.06);
      overflow: hidden;
      transform: perspective(900px) rotateX(1.2deg);
    }

    /* slight barrel/vignette */
    .screen::before{
      content:"";
      position:absolute;
      inset:-12%;
      background:
        radial-gradient(closest-side at 50% 50%,
          rgba(0,0,0,0) 55%,
          rgba(0,0,0,.32) 75%,
          rgba(0,0,0,.75) 100%);
      pointer-events:none;
      filter: blur(1px);
      z-index: 6;
    }

    /* scanlines */
    .scanlines{
      position:absolute;
      inset:0;
      background:
        repeating-linear-gradient(
          180deg,
          var(--scanlineA) 0px,
          var(--scanlineA) 1px,
          var(--scanlineB) 2px,
          rgba(0,0,0,0) 4px
        );
      opacity: .55;
      mix-blend-mode: multiply;
      animation: drift 9s linear infinite;
      pointer-events:none;
      z-index: 4;
    }

    @keyframes drift {
      0% { transform: translateY(0); }
      100% { transform: translateY(32px); }
    }

    /* faint rolling bright band */
    .roll {
      position:absolute;
      inset:0;
      background: linear-gradient(
        180deg,
        rgba(73,255,138,0) 0%,
        rgba(73,255,138,.05) 45%,
        rgba(73,255,138,.12) 50%,
        rgba(73,255,138,.05) 55%,
        rgba(73,255,138,0) 100%
      );
      opacity:.35;
      transform: translateY(-120%);
      animation: roll 7.5s linear infinite;
      pointer-events:none;
      z-index: 5;
      mix-blend-mode: screen;
    }
    @keyframes roll{
      0%{ transform: translateY(-120%); }
      100%{ transform: translateY(120%); }
    }

    /* noise overlay (JS supplies background-image) */
    .noise {
      position:absolute;
      inset:0;
      opacity:.08;
      mix-blend-mode: overlay;
      background-size: 240px 240px;
      animation: noiseShift 1.6s steps(8) infinite;
      pointer-events:none;
      z-index: 3;
      filter: contrast(115%) brightness(90%);
    }
    @keyframes noiseShift{
      0%{ transform: translate(0,0); }
      20%{ transform: translate(-2px,1px); }
      40%{ transform: translate(1px,-1px); }
      60%{ transform: translate(-1px,-2px); }
      80%{ transform: translate(2px,1px); }
      100%{ transform: translate(0,0); }
    }

    /* subtle flicker */
    .flicker {
      position:absolute;
      inset:0;
      background: rgba(255,255,255,.02);
      opacity: 0;
      animation: flicker 6.2s infinite;
      pointer-events:none;
      z-index: 2;
    }
    @keyframes flicker{
      0%, 100% { opacity: 0; }
      4% { opacity: .08; }
      5% { opacity: 0; }
      45% { opacity: 0; }
      46% { opacity: .05; }
      47% { opacity: 0; }
      92% { opacity: 0; }
      93% { opacity: .07; }
      94% { opacity: 0; }
    }

    /* content */
    .content {
      position:absolute;
      inset: 22px 24px;
      color: var(--phosphor);
      z-index: 1;
      text-shadow:
        0 0 8px var(--glow),
        0 0 18px rgba(73,255,138,.15);
      filter: saturate(120%);
    }

    .header {
      display:flex;
      justify-content: space-between;
      align-items: baseline;
      font-size: 14px;
      letter-spacing: .08em;
      opacity:.85;
      margin-bottom: 10px;
      user-select:none;
    }

    .header .left {
      display:flex;
      gap: 10px;
      align-items: baseline;
    }

    .pill{
      padding: 3px 10px;
      border-radius: 999px;
      border: 1px solid rgba(73,255,138,.22);
      background: rgba(73,255,138,.06);
      box-shadow: 0 0 18px rgba(73,255,138,.06) inset;
      font-size: 12px;
      letter-spacing: .12em;
      text-transform: uppercase;
    }

    .terminal {
      height: calc(100% - 34px);
      overflow: hidden;
      font-size: clamp(14px, 1.1vw, 18px);
      line-height: 1.35;
      white-space: pre;
    }

    .line { color: rgba(73,255,138,.92); }
    .dim  { color: var(--phosphor-dim); }
    .warn { color: rgba(255, 240, 120, .85); text-shadow: 0 0 10px rgba(255,240,120,.15); }
    .err  { color: rgba(255, 110, 110, .9); text-shadow: 0 0 12px rgba(255,110,110,.18); }
    .sys  { color: rgba(120, 255, 210, .9); text-shadow: 0 0 10px rgba(120,255,210,.14); }

    .cursor {
      display: inline-block;
      width: .65ch;
      transform: translateY(1px);
      background: rgba(73,255,138,.9);
      box-shadow: 0 0 10px rgba(73,255,138,.35);
      animation: blink 1.1s steps(1) infinite;
    }

    @keyframes blink{
      0%, 49% { opacity: 1; }
      50%, 100% { opacity: 0; }
    }

    /* occasional glitch jitter (applied to .screen) */
    .glitch {
      animation: glitch 180ms steps(2) 1;
    }
    @keyframes glitch {
      0% { transform: perspective(900px) rotateX(1.2deg) translate(0,0); filter: hue-rotate(0deg) contrast(1); }
      25% { transform: perspective(900px) rotateX(1.2deg) translate(2px,-1px); filter: hue-rotate(8deg) contrast(1.12); }
      50% { transform: perspective(900px) rotateX(1.2deg) translate(-2px,1px); filter: hue-rotate(-6deg) contrast(1.05); }
      75% { transform: perspective(900px) rotateX(1.2deg) translate(1px,2px); filter: hue-rotate(5deg) contrast(1.1); }
      100% { transform: perspective(900px) rotateX(1.2deg) translate(0,0); filter: hue-rotate(0deg) contrast(1); }
    }

    /* tiny “phosphor persistence” vibe by duplicating */
    .ghost {
      position:absolute;
      inset: 22px 24px;
      color: rgba(73,255,138,.12);
      z-index: 0;
      filter: blur(.6px);
      pointer-events:none;
      mix-blend-mode: screen;
      transform: translate(1px, 0);
      opacity:.35;
    }

    /* bottom status bar */
    .status {
      position:absolute;
      left: 24px;
      right: 24px;
      bottom: 14px;
      display:flex;
      justify-content: space-between;
      font-size: 12px;
      letter-spacing: .08em;
      opacity: .75;
      user-select:none;
      z-index: 7;
      pointer-events:none;
    }

    .kbdhint{
      opacity:.55;
    }

    /* keep text crisp-ish */
    * { -webkit-font-smoothing: antialiased; -moz-osx-font-smoothing: grayscale; }
  </style>
</head>
<body>
  <div class="crt">
    <div class="screen" id="screen">
      <div class="noise" id="noise"></div>
      <div class="flicker"></div>
      <div class="scanlines"></div>
      <div class="roll"></div>

      <div class="ghost" id="ghost"></div>

      <div class="content">
        <div class="header">
          <div class="left">
            <span class="pill">CRT/TTY</span>
            <span class="dim" id="session">SESSION: 00A7-3F2C</span>
          </div>
          <div class="dim" id="clock">--:--:--</div>
        </div>

        <div class="terminal" id="term" aria-label="CRT terminal output"></div>
      </div>

      <div class="status">
        <div class="dim" id="statusLeft">LINK: UP · BAUD: 9600 · MODE: DIAG</div>
        <div class="kbdhint dim">F11 fullscreen · space: glitch · r: reset</div>
      </div>
    </div>
  </div>

  <script>
    (() => {
      const screen = document.getElementById('screen');
      const term = document.getElementById('term');
      const ghost = document.getElementById('ghost');
      const noiseEl = document.getElementById('noise');
      const clockEl = document.getElementById('clock');
      const sessionEl = document.getElementById('session');
      const statusLeftEl = document.getElementById('statusLeft');

      // --- helpers
      const rand = (min, max) => Math.random() * (max - min) + min;
      const randi = (min, max) => Math.floor(rand(min, max + 1));
      const pick = (arr) => arr[Math.floor(Math.random() * arr.length)];

      const hex = (n) => n.toString(16).toUpperCase().padStart(2, '0');
      const makeSession = () => {
        const a = Array.from({length: 4}, () => hex(randi(0,255))).join('');
        const b = Array.from({length: 2}, () => hex(randi(0,255))).join('');
        return `${a.slice(0,4)}-${a.slice(4)}${b}`;
      };
      sessionEl.textContent = `SESSION: ${makeSession()}`;

      function nowStamp() {
        const d = new Date();
        const hh = String(d.getHours()).padStart(2,'0');
        const mm = String(d.getMinutes()).padStart(2,'0');
        const ss = String(d.getSeconds()).padStart(2,'0');
        return `${hh}:${mm}:${ss}`;
      }

      function updateClock(){
        clockEl.textContent = nowStamp();
      }
      updateClock();
      setInterval(updateClock, 250);

      // --- noise texture (no external assets)
      const noiseCanvas = document.createElement('canvas');
      const nctx = noiseCanvas.getContext('2d', { willReadFrequently: true });
      const NOISE_SIZE = 220;

      function regenNoise(){
        noiseCanvas.width = NOISE_SIZE;
        noiseCanvas.height = NOISE_SIZE;
        const img = nctx.createImageData(NOISE_SIZE, NOISE_SIZE);
        const d = img.data;
        for (let i = 0; i < d.length; i += 4) {
          const v = (Math.random() * 255) | 0;
          d[i] = v; d[i+1] = v; d[i+2] = v;
          d[i+3] = (Math.random() * 80) | 0;
        }
        nctx.putImageData(img, 0, 0);
        noiseEl.style.backgroundImage = `url(${noiseCanvas.toDataURL('image/png')})`;
      }
      regenNoise();
      setInterval(regenNoise, 900);

      // --- terminal buffer + typing
      const MAX_LINES = 240;          // visible-ish history (kept in buffer)
      const VISIBLE_LINES = 120;      // displayed
      const buffer = [];

      function pushLine(text, cls="line") {
        buffer.push({ text, cls });
        while (buffer.length > MAX_LINES) buffer.shift();
        render();
      }

      function render() {
        // show tail
        const slice = buffer.slice(-VISIBLE_LINES);

        // main text
        term.innerHTML = slice.map(l => {
          const safe = l.text
            .replaceAll("&", "&amp;")
            .replaceAll("<", "&lt;")
            .replaceAll(">", "&gt;");
          return `<span class="${l.cls}">${safe}</span>`;
        }).join("\n") + `<span class="cursor"></span>`;

        // ghost layer: slightly older frame
        const ghostSlice = buffer.slice(-Math.min(VISIBLE_LINES, 70));
        ghost.textContent = ghostSlice.map(l => l.text).join("\n");
      }

      // --- nonsense log generator
      const modules = ["KERNEL", "I/O", "NET", "FS", "AUTH", "SCHED", "TTY", "MMU", "IPC", "SENSOR", "BUS", "DMA"];
      const verbs = ["probe", "sync", "alloc", "commit", "flush", "rekey", "handshake", "enumerate", "decode", "patch", "route", "throttle"];
      const nouns = ["buffer", "frame", "inode", "sector", "token", "socket", "page", "vector", "interrupt", "route", "descriptor", "entropy"];
      const statuses = ["OK", "OK", "OK", "WARN", "OK", "OK", "OK", "ERR", "OK", "WARN", "OK"];
      const tags = ["DBG", "INF", "INF", "INF", "WRN", "INF", "ERR"];

      function fakeChecksum() {
        let s = "";
        for (let i=0;i<8;i++) s += hex(randi(0,255));
        return s;
      }

      function fakeAddr() {
        return "0x" + Array.from({length: 4}, () => hex(randi(0,255))).join('');
      }

      function makeLogLine() {
        const t = nowStamp();
        const mod = pick(modules);
        const tag = pick(tags);
        const st = pick(statuses);
        const v = pick(verbs);
        const n = pick(nouns);
        const num = randi(0, 9999).toString().padStart(4,'0');
        const a = fakeAddr();
        const c = fakeChecksum();
        const extra = pick([
          `lat=${rand(0.2, 8.9).toFixed(2)}ms`,
          `q=${randi(0, 64)}`,
          `rx=${randi(0, 4096)}B`,
          `tx=${randi(0, 4096)}B`,
          `ttl=${randi(8, 128)}`,
          `seq=${randi(0, 999999)}`,
          `temp=${rand(18, 76).toFixed(1)}C`,
          `err=${randi(0, 7)}`,
          `thr=${rand(0.1, 1.0).toFixed(2)}`
        ]);

        let cls = "line";
        if (st === "WARN") cls = "warn";
        if (st === "ERR") cls = "err";

        const msg = `${t} [${tag}] ${mod.padEnd(6)} ${v} ${n}#${num} @${a} (${extra}) :: ${st} [${c}]`;
        return { msg, cls };
      }

      // --- “system message” generator
      const systemMsgs = [
        "SYSTEM: periodic self-test scheduled",
        "SYSTEM: signal integrity nominal",
        "SYSTEM: watch-dog timer reset (soft)",
        "SYSTEM: thermal compensation engaged",
        "SYSTEM: timebase drift corrected",
        "SYSTEM: maintenance window deferred",
        "SYSTEM: rerouting packets via secondary path",
        "SYSTEM: checksum mismatch corrected (shadow copy)",
        "SYSTEM: disk scrub cycle complete",
        "SYSTEM: privilege boundary verified"
      ];

      function pushSystemMessage() {
        const t = nowStamp();
        const msg = `${t} [SYS] ${pick(systemMsgs)}`;
        pushLine(msg, "sys");
      }

      // --- boot sequence
      const boot = [
        { t: "00:00:00", cls: "dim", text: "BOOTSTRAP: initializing vector table..." },
        { t: "00:00:01", cls: "dim", text: "BOOTSTRAP: checking memory map... OK" },
        { t: "00:00:02", cls: "dim", text: "BOOTSTRAP: loading microcode... OK" },
        { t: "00:00:03", cls: "dim", text: "TTY: attaching terminal @9600 baud..." },
        { t: "00:00:04", cls: "dim", text: "NET: bringing interface up... OK" },
        { t: "00:00:05", cls: "dim", text: "FS: mounting volumes... OK" },
        { t: "00:00:06", cls: "dim", text: "AUTH: establishing session keys... OK" },
        { t: "00:00:07", cls: "dim", text: "SCHED: starting scheduler... OK" },
        { t: "00:00:08", cls: "line", text: "READY." },
      ];

      function resetTerminal() {
        buffer.length = 0;
        render();
        sessionEl.textContent = `SESSION: ${makeSession()}`;
        statusLeftEl.textContent = `LINK: UP · BAUD: 9600 · MODE: DIAG`;
        // play boot with slight delays
        let i = 0;
        const bootTimer = setInterval(() => {
          const b = boot[i++];
          if (!b) { clearInterval(bootTimer); return; }
          pushLine(`${b.t} ${b.text}`, b.cls);
          if (i === boot.length) {
            // add a prompt-ish line
            pushLine(`${nowStamp()} [INF] TTY    await input...`, "dim");
          }
        }, 280);
      }

      // --- typing cadence: “blinking cursor types nonsense logs”
      let typing = false;
      let nextSystemAt = Date.now() + randi(4000, 12000);
      let nextGlitchAt = Date.now() + randi(8000, 18000);

      function tick() {
        // variable cadence feels more real
        const base = typing ? randi(40, 120) : randi(90, 220);
        setTimeout(tick, base);

        // randomly switch between bursts and idle
        if (Math.random() < 0.015) typing = !typing;

        // add 0-2 lines per tick when typing
        if (typing) {
          const count = Math.random() < 0.22 ? 2 : 1;
          for (let i=0;i<count;i++) {
            const { msg, cls } = makeLogLine();
            pushLine(msg, cls);
          }
        } else {
          // occasional dim heartbeat
          if (Math.random() < 0.03) {
            pushLine(`${nowStamp()} [DBG] HEART  tick=${randi(100000,999999)} jitter=${rand(0.0,0.9).toFixed(2)}`, "dim");
          }
        }

        // system messages
        const now = Date.now();
        if (now > nextSystemAt) {
          pushSystemMessage();
          nextSystemAt = now + randi(6000, 22000);
        }

        // tiny status variations
        if (Math.random() < 0.01) {
          const modes = ["DIAG", "MON", "SAFE", "RUN", "AUDIT"];
          statusLeftEl.textContent =
            `LINK: UP · BAUD: 9600 · MODE: ${pick(modes)} · RSSI: ${randi(62,98)}%`;
        }

        // glitch occasionally
        if (now > nextGlitchAt) {
          maybeGlitch();
          nextGlitchAt = now + randi(11000, 26000);
        }
      }

      function maybeGlitch(force=false) {
        if (!force && Math.random() < 0.35) return;

        screen.classList.remove('glitch');
        // force reflow so animation restarts
        void screen.offsetWidth;
        screen.classList.add('glitch');

        // drop in a “corruption” line sometimes
        if (Math.random() < 0.6) {
          const t = nowStamp();
          const junk = Array.from({length: randi(14, 36)}, () => String.fromCharCode(randi(33, 126))).join("");
          pushLine(`${t} [WRN] MMU    transient corruption detected :: "${junk}"`, "warn");
        }
      }

      // controls
      window.addEventListener('keydown', (e) => {
        if (e.key === ' ') maybeGlitch(true);
        if (e.key.toLowerCase() === 'r') resetTerminal();
        if (e.key === 'F11') {
          // let the browser handle it; just prevent accidental scroll
          e.preventDefault();
        }
      });

      // go
      resetTerminal();
      // prime with a bit of output so it looks alive immediately
      for (let i=0;i<18;i++){
        const { msg, cls } = makeLogLine();
        pushLine(msg, cls);
      }
      typing = true;
      tick();
    })();
  </script>
</body>
</html>

