<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Hourglass</title>
  <style>
    :root{
      --bg1:#07090f;
      --bg2:#0b1326;
      --bg3:#05060a;
    }
    html,body{
      height:100%;
      margin:0;
      background:
        radial-gradient(1200px 800px at 50% 35%, rgba(255,255,255,0.06), transparent 60%),
        radial-gradient(900px 600px at 50% 75%, rgba(127,170,255,0.06), transparent 65%),
        linear-gradient(180deg, var(--bg2), var(--bg1) 40%, var(--bg3));
      overflow:hidden;
      font-family: system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, sans-serif;
      cursor:none;
    }
    canvas{ display:block; width:100vw; height:100vh; }
  </style>
</head>
<body>
<canvas id="c"></canvas>

<script>
(() => {
  "use strict";

  const params = new URLSearchParams(location.search);
  const TEST_MODE = params.get("test") === "1";          // flips every minute
  const FLOW_MULT = Number(params.get("flow")) || 1.0;   // e.g. ?flow=1.2

  const CFG = {
    flipDurationMs: 4800,
    grainsMax: 950,
    grainsSpawnPerSec: 170,   // visual stream density
    gravity: 2.35,
    airDrag: 0.985,
    neckJitter: 0.010,
    sparkleChance: 0.010,
    flowRatePerSec: (TEST_MODE ? 0.22 : (1 / 3600)) * 1.05 * FLOW_MULT
  };

  const canvas = document.getElementById("c");
  const ctx = canvas.getContext("2d");

  let DPR = Math.max(1, Math.min(2, window.devicePixelRatio || 1));
  function resize(){
    canvas.width = Math.floor(innerWidth * DPR);
    canvas.height = Math.floor(innerHeight * DPR);
  }
  addEventListener("resize", () => { DPR = Math.max(1, Math.min(2, window.devicePixelRatio || 1)); resize(); });
  resize();

  function fit(){
    const w = canvas.width, h = canvas.height;
    const s = Math.min(w, h) * 0.62;
    return { s, cx: w*0.5, cy: h*0.52, w, h };
  }

  // Geometry (interior)
  const G = {
    yTop: -0.92,
    yNeck: 0.0,
    yBottom: 0.92,
    maxW: 0.58,    // bulb width near ends
    neckW: 0.06,   // waist width
    curvePow: 1.75 // bigger => rounder bulbs
  };

  // âœ… Correct: narrow at neck, wide at bulb ends
  function widthAtY(y){
    const t = Math.min(1, Math.max(0, Math.abs(y) / G.yBottom)); // 0 at neck, 1 at ends
    const bulge = Math.pow(t, G.curvePow);
    return G.neckW + (G.maxW - G.neckW) * bulge;
  }

  // State
  let topFill = 1.0;
  let bottomFill = 0.0;
  const grains = [];

  const flip = { active:false, t:0, angle:0, swapped:false };

  function hash(n){
    n = Math.sin(n) * 43758.5453123;
    return n - Math.floor(n);
  }
  function easeInOutCubic(t){
    t = Math.max(0, Math.min(1, t));
    return t < 0.5 ? 4*t*t*t : 1 - Math.pow(-2*t+2, 3)/2;
  }

  // Scheduling flips (top-of-hour)
  function scheduleNextFlip(){
    const now = new Date();
    const next = new Date(now);
    if (TEST_MODE){
      next.setSeconds(0,0);
      next.setMinutes(now.getMinutes() + 1);
    } else {
      next.setMinutes(0,0,0);
      next.setHours(now.getHours() + 1);
    }
    const ms = Math.max(0, next - now);
    setTimeout(() => { startFlip(); scheduleNextFlip(); }, ms);
  }
  function startFlip(){
    if (flip.active) return;
    flip.active = true;
    flip.t = 0;
    flip.angle = 0;
    flip.swapped = false;
  }
  scheduleNextFlip();

  // Sand surfaces
  function topSurfaceBaseY(fill){
    const f = Math.pow(fill, 0.62);
    return -0.06 - 0.74 * f; // near neck when low, toward top when full
  }
  function bottomSurfaceBaseY(fill){
    const f = Math.pow(fill, 0.60);
    return 0.86 - 0.74 * f;  // near bottom when low, toward neck when full
  }
  function surfaceNoise(nx, seed){
    const a = hash((nx*7.1 + seed)*13.37);
    const b = hash((nx*11.3 + seed)*9.91);
    return (a*2-1)*0.006 + (b*2-1)*0.004;
  }
  function topSurfaceY(x, fill){
    const base = topSurfaceBaseY(fill);
    const xEdge = widthAtY(base) * 0.98;
    const nx = Math.max(-1, Math.min(1, x / xEdge));
    const moundAmp = 0.18*(1-fill) + 0.03*(fill);
    const mound = moundAmp * (1 - nx*nx); // peaks toward neck
    const edgeFade = (1 - nx*nx);
    return base + mound + surfaceNoise(nx, 0.41) * edgeFade;
  }
  function bottomSurfaceY(x, fill){
    const base = bottomSurfaceBaseY(fill);
    const xEdge = widthAtY(base) * 0.98;
    const nx = Math.max(-1, Math.min(1, x / xEdge));
    const moundAmp = 0.22*(1-fill) + 0.05*(fill);
    const mound = -moundAmp * (1 - nx*nx); // peak rises up (smaller y)
    const edgeFade = (1 - nx*nx);
    return base + mound + surfaceNoise(nx, 0.77) * edgeFade;
  }

  // roundRect polyfill
  if (!CanvasRenderingContext2D.prototype.roundRect){
    CanvasRenderingContext2D.prototype.roundRect = function(x,y,w,h,r){
      const rr = Math.min(r, w/2, h/2);
      this.beginPath();
      this.moveTo(x+rr, y);
      this.arcTo(x+w, y, x+w, y+h, rr);
      this.arcTo(x+w, y+h, x, y+h, rr);
      this.arcTo(x, y+h, x, y, rr);
      this.arcTo(x, y, x+w, y, rr);
      this.closePath();
      return this;
    };
  }

  // Paths
  function pathInterior(){
    ctx.beginPath();
    const y0 = G.yTop, y1 = G.yBottom;
    const steps = 90;

    for (let i=0;i<=steps;i++){
      const t = i/steps;
      const y = y0 + (y1-y0)*t;
      const x = -widthAtY(y);
      if (i===0) ctx.moveTo(x,y); else ctx.lineTo(x,y);
    }
    for (let i=steps;i>=0;i--){
      const t = i/steps;
      const y = y0 + (y1-y0)*t;
      const x = widthAtY(y);
      ctx.lineTo(x,y);
    }
    ctx.closePath();
  }

  function pathOuterGlass(){
    ctx.beginPath();
    const y0 = G.yTop - 0.06, y1 = G.yBottom + 0.06;
    const steps = 100;

    for (let i=0;i<=steps;i++){
      const t = i/steps;
      const y = y0 + (y1-y0)*t;
      const clampedY = Math.max(G.yTop, Math.min(G.yBottom, y));
      const inner = widthAtY(clampedY);
      // slightly thicker near bulbs, slimmer near neck
      const tt = Math.min(1, Math.max(0, Math.abs(clampedY)/G.yBottom));
      const thickness = 0.075 + 0.020*Math.pow(tt, 0.8);
      const x = -(inner + thickness);
      if (i===0) ctx.moveTo(x,y); else ctx.lineTo(x,y);
    }
    for (let i=steps;i>=0;i--){
      const t = i/steps;
      const y = y0 + (y1-y0)*t;
      const clampedY = Math.max(G.yTop, Math.min(G.yBottom, y));
      const inner = widthAtY(clampedY);
      const tt = Math.min(1, Math.max(0, Math.abs(clampedY)/G.yBottom));
      const thickness = 0.075 + 0.020*Math.pow(tt, 0.8);
      const x = (inner + thickness);
      ctx.lineTo(x,y);
    }
    ctx.closePath();
  }

  function drawStand(){
    const capW = 0.82, capH = 0.085;
    const baseW = 0.92, baseH = 0.11;

    ctx.save();
    ctx.translate(0, G.yTop - 0.12);
    ctx.roundRect(-capW/2, -capH/2, capW, capH, 0.06);
    const g1 = ctx.createLinearGradient(0, -capH/2, 0, capH/2);
    g1.addColorStop(0, "rgba(255,255,255,0.22)");
    g1.addColorStop(0.55, "rgba(160,190,225,0.10)");
    g1.addColorStop(1, "rgba(0,0,0,0.40)");
    ctx.fillStyle = g1; ctx.fill();
    ctx.strokeStyle = "rgba(255,255,255,0.12)";
    ctx.lineWidth = 0.012; ctx.stroke();
    ctx.restore();

    ctx.save();
    ctx.translate(0, G.yBottom + 0.14);
    ctx.roundRect(-baseW/2, -baseH/2, baseW, baseH, 0.07);
    const g2 = ctx.createLinearGradient(0, -baseH/2, 0, baseH/2);
    g2.addColorStop(0, "rgba(255,255,255,0.18)");
    g2.addColorStop(0.55, "rgba(120,150,190,0.10)");
    g2.addColorStop(1, "rgba(0,0,0,0.48)");
    ctx.fillStyle = g2; ctx.fill();
    ctx.strokeStyle = "rgba(255,255,255,0.10)";
    ctx.lineWidth = 0.012; ctx.stroke();
    ctx.restore();
  }

  function drawSand(){
    const sandGradTop = ctx.createLinearGradient(0, -0.95, 0, 0.05);
    sandGradTop.addColorStop(0, "rgba(245, 210, 145, 0.70)");
    sandGradTop.addColorStop(0.55, "rgba(225, 180, 110, 0.88)");
    sandGradTop.addColorStop(1, "rgba(175, 120, 68, 0.92)");

    const sandGradBottom = ctx.createLinearGradient(0, 0.05, 0, 0.95);
    sandGradBottom.addColorStop(0, "rgba(240, 200, 130, 0.68)");
    sandGradBottom.addColorStop(0.55, "rgba(215, 165, 100, 0.88)");
    sandGradBottom.addColorStop(1, "rgba(155, 105, 62, 0.95)");

    ctx.save();
    pathInterior();
    ctx.clip();

    // Top chamber sand
    {
      const base = topSurfaceBaseY(topFill);
      const xEdge = widthAtY(base) * 0.98;
      const neckW = widthAtY(0);

      ctx.beginPath();
      ctx.moveTo(-neckW, 0);

      const wallSteps = 56;
      for (let i=0;i<=wallSteps;i++){
        const t = i/wallSteps;
        const y = 0 + (base - 0)*t;
        ctx.lineTo(widthAtY(y), y);
      }
      const sSteps = 80;
      for (let i=0;i<=sSteps;i++){
        const t = i/sSteps;
        const x = xEdge - 2*xEdge*t;
        ctx.lineTo(x, topSurfaceY(x, topFill));
      }
      for (let i=wallSteps;i>=0;i--){
        const t = i/wallSteps;
        const y = 0 + (base - 0)*t;
        ctx.lineTo(-widthAtY(y), y);
      }
      ctx.closePath();

      ctx.fillStyle = sandGradTop;
      ctx.fill();

      ctx.globalAlpha = 0.10;
      for (let i=0;i<220;i++){
        const rx = (hash(i*12.1)-0.5) * xEdge * 1.7;
        const ry = 0 + (hash(i*99.3))*(base - 0);
        const r = (0.002 + hash(i*3.7)*0.004);
        ctx.beginPath();
        ctx.arc(rx, ry, r, 0, Math.PI*2);
        ctx.fillStyle = "rgba(255,255,255,1)";
        ctx.fill();
      }
      ctx.globalAlpha = 1;
    }

    // Bottom chamber sand
    {
      const base = bottomSurfaceBaseY(bottomFill);
      const xEdge = widthAtY(base) * 0.98;
      const yBot = G.yBottom;

      ctx.beginPath();
      ctx.moveTo(-xEdge, bottomSurfaceY(-xEdge, bottomFill));
      const sSteps = 90;
      for (let i=0;i<=sSteps;i++){
        const t = i/sSteps;
        const x = -xEdge + 2*xEdge*t;
        ctx.lineTo(x, bottomSurfaceY(x, bottomFill));
      }

      const wallSteps = 70;
      for (let i=0;i<=wallSteps;i++){
        const t = i/wallSteps;
        const y = base + (yBot - base)*t;
        ctx.lineTo(widthAtY(y), y);
      }
      for (let i=wallSteps;i>=0;i--){
        const t = i/wallSteps;
        const y = base + (yBot - base)*t;
        ctx.lineTo(-widthAtY(y), y);
      }
      ctx.closePath();

      ctx.fillStyle = sandGradBottom;
      ctx.fill();

      ctx.globalAlpha = 0.10;
      for (let i=0;i<260;i++){
        const rx = (hash(i*22.7)-0.5) * xEdge * 1.8;
        const ry = base + (hash(i*88.8))*(yBot - base);
        const r = (0.002 + hash(i*5.2)*0.004);
        ctx.beginPath();
        ctx.arc(rx, ry, r, 0, Math.PI*2);
        ctx.fillStyle = "rgba(255,255,255,1)";
        ctx.fill();
      }
      ctx.globalAlpha = 1;
    }

    // Falling grains
    for (const g of grains){
      const a = Math.max(0, Math.min(1, g.life));
      ctx.globalAlpha = a * 0.85;
      ctx.beginPath();
      ctx.arc(g.x, g.y, g.r, 0, Math.PI*2);
      ctx.fillStyle = g.sparkle ? "rgba(255,255,255,1)" : "rgba(235,185,110,1)";
      ctx.fill();
    }
    ctx.globalAlpha = 1;

    // neck shimmer
    ctx.beginPath();
    ctx.moveTo(-widthAtY(0), 0);
    ctx.lineTo(widthAtY(0), 0);
    ctx.strokeStyle = "rgba(255,255,255,0.06)";
    ctx.lineWidth = 0.008;
    ctx.stroke();

    ctx.restore();
  }

  function drawGlass(){
    ctx.save();

    // soft shadow behind the glass
    ctx.shadowColor = "rgba(0,0,0,0.55)";
    ctx.shadowBlur = 16 * DPR;
    ctx.shadowOffsetY = 10 * DPR;

    pathOuterGlass();
    const glassFill = ctx.createLinearGradient(-0.8, -1, 0.8, 1);
    glassFill.addColorStop(0, "rgba(200,225,255,0.06)");
    glassFill.addColorStop(0.35, "rgba(255,255,255,0.02)");
    glassFill.addColorStop(0.70, "rgba(255,255,255,0.03)");
    glassFill.addColorStop(1, "rgba(110,150,220,0.05)");
    ctx.fillStyle = glassFill;
    ctx.fill();

    ctx.shadowColor = "transparent";
    ctx.strokeStyle = "rgba(255,255,255,0.22)";
    ctx.lineWidth = 0.018;
    ctx.stroke();

    // inner rim
    ctx.save();
    ctx.globalAlpha = 0.9;
    pathInterior();
    ctx.strokeStyle = "rgba(255,255,255,0.12)";
    ctx.lineWidth = 0.012;
    ctx.stroke();
    ctx.restore();

    // specular highlights
    ctx.save();
    pathOuterGlass();
    ctx.clip();

    const hl = ctx.createLinearGradient(-0.60, -1, 0.15, 1);
    hl.addColorStop(0.00, "rgba(255,255,255,0.00)");
    hl.addColorStop(0.18, "rgba(255,255,255,0.11)");
    hl.addColorStop(0.28, "rgba(255,255,255,0.03)");
    hl.addColorStop(0.52, "rgba(255,255,255,0.00)");
    ctx.fillStyle = hl;
    ctx.fillRect(-1, -1.2, 2, 2.4);

    const hl2 = ctx.createLinearGradient(0.10, -1, 0.75, 1);
    hl2.addColorStop(0.00, "rgba(255,255,255,0.00)");
    hl2.addColorStop(0.32, "rgba(255,255,255,0.05)");
    hl2.addColorStop(0.55, "rgba(255,255,255,0.00)");
    ctx.fillStyle = hl2;
    ctx.fillRect(-1, -1.2, 2, 2.4);

    ctx.restore();
    ctx.restore();
  }

  function drawVignette(){
    const {w,h} = fit();
    ctx.save();
    ctx.setTransform(1,0,0,1,0,0);
    const rg = ctx.createRadialGradient(w*0.5, h*0.52, Math.min(w,h)*0.2,
                                       w*0.5, h*0.52, Math.min(w,h)*0.62);
    rg.addColorStop(0, "rgba(0,0,0,0)");
    rg.addColorStop(1, "rgba(0,0,0,0.55)");
    ctx.fillStyle = rg;
    ctx.fillRect(0,0,w,h);
    ctx.restore();
  }

  // Visual grains stream
  function spawnGrains(dt, flow){
    // Keep stream present whenever flow > 0, and taper when nearly empty.
    const topFactor = 0.18 + 0.82 * Math.pow(topFill, 0.35);
    const perSec = CFG.grainsSpawnPerSec * topFactor;
    let count = Math.floor(perSec * (dt/1000));
    count = Math.min(18, Math.max(0, count));
    for (let i=0;i<count;i++){
      if (grains.length >= CFG.grainsMax) break;

      const x = (hash(performance.now()*0.001 + i*13.7) - 0.5) * (widthAtY(0) * 0.60)
              + (hash(performance.now()*0.004 + i*9.1) - 0.5) * CFG.neckJitter;

      grains.push({
        x,
        y: -0.012,
        vx: (hash(i*2.9 + performance.now()*0.0009) - 0.5) * 0.04,
        vy: 0.02 + hash(i*7.3 + performance.now()*0.0007) * 0.06,
        r: 0.0035 + hash(i*5.1 + performance.now()*0.0003) * 0.0045,
        life: 1,
        sparkle: (Math.random() < CFG.sparkleChance)
      });
    }
  }

  function update(dt){
    const sec = dt/1000;

    if (flip.active){
      flip.t += dt;
      const t = flip.t / CFG.flipDurationMs;
      const e = easeInOutCubic(t);
      flip.angle = Math.PI * e;

      if (!flip.swapped && t >= 0.5){
        const tmp = topFill; topFill = bottomFill; bottomFill = tmp;
        flip.swapped = true;
        grains.length = 0;
      }
      if (t >= 1){
        flip.active = false;
        flip.angle = 0;
      }
      return;
    }

    const flow = Math.min(topFill, CFG.flowRatePerSec * sec);
    topFill -= flow;
    bottomFill += flow;

    spawnGrains(dt, flow);

    for (let i = grains.length - 1; i >= 0; i--){
      const g = grains[i];
      g.vy += CFG.gravity * sec;
      g.vx *= Math.pow(CFG.airDrag, sec*60);
      g.vy *= Math.pow(CFG.airDrag, sec*60);

      g.x += g.vx * sec;
      g.y += g.vy * sec;

      const w = widthAtY(g.y);
      if (Math.abs(g.x) > w*0.95){
        g.x = Math.sign(g.x) * w*0.95;
        g.vx *= -0.2;
      }

      g.life -= sec * 0.55;

      const surface = bottomSurfaceY(g.x, bottomFill);
      if (g.y >= surface - 0.01){
        g.y = surface - 0.01;
        g.vy *= -0.15;
        g.vx *= 0.35;
        g.life -= sec * 2.8;
        g.sparkle = false;
      }

      if (g.y > G.yBottom + 0.06 || g.life <= 0){
        grains.splice(i, 1);
      }
    }

    topFill = Math.max(0, Math.min(1, topFill));
    bottomFill = Math.max(0, Math.min(1, bottomFill));
  }

  let last = performance.now();
  function frame(now){
    const dt = Math.min(34, now - last);
    last = now;

    update(dt);

    const { s, cx, cy, w, h } = fit();
    ctx.setTransform(1,0,0,1,0,0);
    ctx.clearRect(0,0,w,h);

    // faint background dust
    ctx.save();
    ctx.globalAlpha = 0.055;
    for (let i=0;i<22;i++){
      const t = now*0.00012 + i*13.1;
      const px = cx + Math.sin(t*1.7) * s*0.8 + (hash(i*19.3)-0.5)*s*0.2;
      const py = cy + Math.cos(t*1.2) * s*0.55 + (hash(i*7.7)-0.5)*s*0.2;
      const r = (0.9 + hash(i*3.3)) * 2.2 * DPR;
      ctx.beginPath();
      ctx.arc(px, py, r, 0, Math.PI*2);
      ctx.fillStyle = "rgba(255,255,255,1)";
      ctx.fill();
    }
    ctx.restore();

    // hourglass
    ctx.save();
    ctx.translate(cx, cy);
    ctx.scale(s, s);
    ctx.rotate(flip.angle);

    drawStand();
    drawSand();
    drawGlass();

    ctx.restore();
    drawVignette();

    requestAnimationFrame(frame);
  }
  requestAnimationFrame(frame);

  addEventListener("keydown", (e) => {
    if (e.key === "f" || e.key === "F") startFlip();
    if (e.key === "r" || e.key === "R"){ topFill = 1; bottomFill = 0; grains.length = 0; }
  });
})();
</script>
</body>
</html>

