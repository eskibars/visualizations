<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Rainy Window</title>
  <style>
    :root{
      /* Brighter overall grade */
      --skyTop: #182a4a;
      --skyMid: #0d1730;
      --skyBot: #060812;

      /* Less tint so you can actually see the scene */
      --glassTint: rgba(10, 16, 28, 0.22);
      --vignette: rgba(0,0,0,0.32);
    }

    html, body {
      margin: 0;
      height: 100%;
      overflow: hidden;
      background: #05060b;
      font-family: system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, sans-serif;
    }

    #wrap {
      position: fixed;
      inset: 0;
    }

    canvas{
      position: absolute;
      inset: 0;
      width: 100%;
      height: 100%;
      display: block;
    }

    /* Gentle grade overlays */
    #tint {
      position: absolute;
      inset: 0;
      background: var(--glassTint);
      pointer-events: none;
      mix-blend-mode: multiply;
    }

    #vignette {
      position: absolute;
      inset: 0;
      pointer-events: none;
      background:
        radial-gradient(120% 95% at 50% 45%, rgba(0,0,0,0) 0%, rgba(0,0,0,0.18) 58%, var(--vignette) 100%);
      mix-blend-mode: multiply;
    }
  </style>
</head>
<body>
  <div id="wrap">
    <canvas id="city"></canvas>
    <canvas id="rain"></canvas>
    <div id="tint"></div>
    <div id="vignette"></div>
  </div>

<script>
(() => {
  /* ===========
     TUNING
     =========== */
  const CFG = {
    // If itâ€™s still heavy on your display hardware, set 'low'
    quality: 'med', // 'low' | 'med' | 'high'

    // Parallax: pointer move (or idle drift) shifts city lights subtly
    parallaxPx: 18,

    // Lightning frequency
    lightningChancePerSecond: 0.06,

    // DPR cap keeps 4K signage from melting
    dprCap: 1.25,
  };

  let skyline = null;

function buildSkyline() {
  const groundY = H * 0.76;
  const buildings = [];

  let x = -W * 0.05;
  const nBuildings = 28;

  for (let i = 0; i < nBuildings; i++) {
    const bw = rand(W * 0.03, W * 0.085);
    const bh = rand(H * 0.12, H * 0.44);
    const bx = x;
    const by = groundY - bh;

    const shade = 0.70 + Math.random() * 0.10;

    // Precompute windows ONCE
    const windows = [];
    const wxCount = (rand(1, 4) | 0);
    const wyCount = (rand(6, 14) | 0);

    for (let wx = 0; wx < wxCount; wx++) {
      for (let wy = 0; wy < wyCount; wy++) {
        if (Math.random() < 0.70) continue; // keep sparse
        const px = bx + 4 + wx * (bw / (wxCount + 1));
        const py = by + 8 + wy * (bh / (wyCount + 1));
        const ww = rand(1, 3);
        const wh = rand(2, 8);
        windows.push({ x: px, y: py, w: ww, h: wh });
      }
    }

    buildings.push({ x: bx, y: by, w: bw, h: bh, shade, windows });

    x += bw * rand(0.75, 1.05);
    if (x > W) break;
  }

  skyline = { groundY, buildings };
}


  const QUAL = {
    low:  { drops: 220, beads: 40,  bokehNear: 110, bokehFar: 160, noiseAlpha: 0.05 },
    med:  { drops: 340, beads: 70,  bokehNear: 160, bokehFar: 230, noiseAlpha: 0.06 },
    high: { drops: 480, beads: 110, bokehNear: 230, bokehFar: 320, noiseAlpha: 0.07 },
  }[CFG.quality] || QUAL.med;

  const cityCanvas = document.getElementById('city');
  const rainCanvas = document.getElementById('rain');
  const cctx = cityCanvas.getContext('2d', { alpha: false });
  const rctx = rainCanvas.getContext('2d', { alpha: true });

  let W=0,H=0,DPR=1;

  /* Offscreen cached city layers */
  let offFar, offNear, offFarCtx, offNearCtx;
  let noiseTile, noiseCtx, noisePattern;

  function rand(a,b){ return a + Math.random()*(b-a); }
  function clamp(x,a,b){ return Math.max(a, Math.min(b,x)); }

  function resize(){
    DPR = Math.min(CFG.dprCap, window.devicePixelRatio || 1);
    W = Math.max(1, Math.floor(window.innerWidth));
    H = Math.max(1, Math.floor(window.innerHeight));

    for (const cnv of [cityCanvas, rainCanvas]){
      cnv.width  = Math.floor(W * DPR);
      cnv.height = Math.floor(H * DPR);
    }
    cctx.setTransform(DPR,0,0,DPR,0,0);
    rctx.setTransform(DPR,0,0,DPR,0,0);

    // Offscreen canvases at reduced res (big speed win)
    const scale = 0.55;
    offFar = document.createElement('canvas');
    offNear = document.createElement('canvas');
    offFar.width = Math.floor(W * scale);
    offFar.height = Math.floor(H * scale);
    offNear.width = Math.floor(W * scale);
    offNear.height = Math.floor(H * scale);
    offFarCtx = offFar.getContext('2d', { alpha: true });
    offNearCtx = offNear.getContext('2d', { alpha: true });

    buildCityLayers(scale);
    buildNoise();
    initRain();
  }
  window.addEventListener('resize', resize, { passive:true });

  /* ===========
     POINTER / PARALLAX
     =========== */
  let pointerX = 0, pointerY = 0;
  let parX = 0, parY = 0;

  window.addEventListener('pointermove', (e) => {
    pointerX = (e.clientX / W) * 2 - 1;
    pointerY = (e.clientY / H) * 2 - 1;
  }, { passive:true });

  /* ===========
     CITY: cached bokeh + skyline
     =========== */
  function drawSky(ctx){
    const g = ctx.createLinearGradient(0,0,0,H);
    g.addColorStop(0.00, getCSS('--skyTop'));
    g.addColorStop(0.45, getCSS('--skyMid'));
    g.addColorStop(1.00, getCSS('--skyBot'));
    ctx.fillStyle = g;
    ctx.fillRect(0,0,W,H);
  }

  function getCSS(varName){
    return getComputedStyle(document.documentElement).getPropertyValue(varName).trim();
  }

  function buildCityLayers(scale){
    // Clear
    offFarCtx.clearRect(0,0,offFar.width,offFar.height);
    offNearCtx.clearRect(0,0,offNear.width,offNear.height);

    // Draw bokeh points with ctx.filter blur ONCE per layer canvas
    const build = (ctx, count, blurPx, alphaBase, warmBias) => {
      ctx.save();
      ctx.filter = `blur(${blurPx}px)`;
      ctx.globalCompositeOperation = 'lighter';

      for (let i=0;i<count;i++){
        const x = Math.random()*offFar.width;
        const yBias = Math.pow(Math.random(), 0.55);
        const y = offFar.height*(0.25 + 0.75*yBias);

        const r = rand(1.4, 7.5) * (warmBias ? 1.0 : 0.9);
        const hue = warmBias
          ? rand(28, 62) + (Math.random()<0.18 ? rand(-25,25) : 0)
          : rand(195, 220) + (Math.random()<0.18 ? rand(-12,12) : 0);

        const sat = warmBias ? rand(58, 90) : rand(35, 70);
        const lum = warmBias ? rand(55, 80) : rand(55, 78);
        const a = rand(alphaBase*0.65, alphaBase*1.2);

        ctx.fillStyle = `hsla(${hue},${sat}%,${lum}%,${a})`;
        ctx.beginPath();
        ctx.arc(x,y,r,0,Math.PI*2);
        ctx.fill();
      }
      ctx.restore();
      ctx.filter = 'none';
      ctx.globalCompositeOperation = 'source-over';
    };

    // Far layer: cooler + smaller
    build(offFarCtx, QUAL.bokehFar, 9, 0.16, false);
    // Near layer: warmer + brighter
    build(offNearCtx, QUAL.bokehNear, 14, 0.22, true);

    // Skyline silhouette on the main city canvas each frame (cheap),
    // but also add a faint static haze into offNear for depth.
    offNearCtx.save();
    const haze = offNearCtx.createLinearGradient(0, offNear.height*0.58, 0, offNear.height);
    haze.addColorStop(0, `rgba(120,170,255,0.10)`);
    haze.addColorStop(1, `rgba(0,0,0,0.25)`);
    offNearCtx.fillStyle = haze;
    offNearCtx.fillRect(0, offNear.height*0.58, offNear.width, offNear.height);
    offNearCtx.restore();
  }

  function drawSkyline(ctx, lightningBoost){
  if (!skyline) return;

  const groundY = skyline.groundY;

  ctx.save();

  // Ground mass
  ctx.globalAlpha = 0.9 - 0.25 * lightningBoost;
  ctx.fillStyle = 'rgba(0,0,0,0.78)';
  ctx.fillRect(0, groundY, W, H - groundY);

  // Buildings + windows (stable)
  for (const b of skyline.buildings) {
    ctx.fillStyle = `rgba(0,0,0,${b.shade})`;
    ctx.fillRect(b.x, b.y, b.w, b.h);

    ctx.globalCompositeOperation = 'lighter';
    ctx.globalAlpha = 0.10 + 0.18 * lightningBoost;
    ctx.fillStyle = 'rgba(255,225,170,1)';
    for (const w of b.windows) ctx.fillRect(w.x, w.y, w.w, w.h);

    ctx.globalCompositeOperation = 'source-over';
    ctx.globalAlpha = 0.9 - 0.25 * lightningBoost;
  }

  // Horizon haze
  ctx.globalAlpha = 0.18 + 0.20 * lightningBoost;
  const haze = ctx.createLinearGradient(0, groundY - H*0.10, 0, H);
  haze.addColorStop(0, 'rgba(140,185,255,0.22)');
  haze.addColorStop(1, 'rgba(0,0,0,0.40)');
  ctx.fillStyle = haze;
  ctx.fillRect(0, groundY - H*0.10, W, H - (groundY - H*0.10));

  ctx.restore();
}


  /* ===========
     NOISE overlay (glass grain) - very cheap
     =========== */
  function buildNoise(){
    noiseTile = document.createElement('canvas');
    const s = 180;
    noiseTile.width = s;
    noiseTile.height = s;
    noiseCtx = noiseTile.getContext('2d', { alpha:true });
    const img = noiseCtx.createImageData(s,s);
    const d = img.data;
    for (let i=0;i<d.length;i+=4){
      const v = (Math.random()*255)|0;
      d[i]=v; d[i+1]=v; d[i+2]=v;
      d[i+3] = (Math.random()*40)|0;
    }
    noiseCtx.putImageData(img,0,0);
    noisePattern = rctx.createPattern(noiseTile,'repeat');
  }

  /* ===========
     RAIN particles (simple, fast)
     =========== */
  let drops = [];
  let beads = [];

  function initRain(){
    drops = Array.from({length: QUAL.drops}, () => ({
      x: Math.random()*W,
      y: Math.random()*H,
      vx: rand(-0.15, 0.35),
      vy: rand(6.0, 12.5),
      len: rand(18, 70),
      w: rand(1.0, 1.8),
      a: rand(0.10, 0.24),
    }));

    beads = Array.from({length: QUAL.beads}, () => ({
      x: Math.random()*W,
      y: Math.random()*H,
      r: rand(1.0, 2.6),
      vy: rand(0.25, 0.85),
      a: rand(0.06, 0.14),
      wob: Math.random()*Math.PI*2,
      wobs: rand(0.6, 1.8),
    }));
  }

  /* ===========
     LIGHTNING (cheap flash)
     =========== */
  const lightning = {
    flash: 0,
    cooldown: rand(2.2, 8.0),
  };

  function tickLightning(dt){
    lightning.flash = Math.max(0, lightning.flash - dt * 2.2);
    lightning.cooldown -= dt;
    if (lightning.cooldown <= 0){
      if (Math.random() < CFG.lightningChancePerSecond * Math.max(0.5, dt)){
        lightning.flash = rand(0.45, 1.0);
        // little secondary flicker
        if (Math.random() < 0.35){
          setTimeout(() => lightning.flash = Math.max(lightning.flash, rand(0.18, 0.55)), rand(80, 220));
        }
        lightning.cooldown = rand(3.2, 10.0);
      } else {
        lightning.cooldown = rand(0.6, 1.6);
      }
    }
    return lightning.flash;
  }

  /* ===========
     MAIN LOOP
     =========== */
  let last = performance.now();

  function frame(now){
    const dt = Math.min(0.05, (now - last)/1000);
    last = now;

    // Parallax: pointer + idle drift for kiosk screens
    const driftX = Math.sin(now*0.00018)*0.55;
    const driftY = Math.cos(now*0.00014)*0.55;

    const tx = (pointerX + driftX) * CFG.parallaxPx;
    const ty = (pointerY + driftY) * CFG.parallaxPx * 0.6;
    parX += (tx - parX) * 0.06;
    parY += (ty - parY) * 0.06;

    const lightningBoost = tickLightning(dt);

    /* ---- CITY ---- */
    drawSky(cctx);

    // Draw cached bokeh with parallax offsets (scaled up from offscreen)
    const scale = offFar.width / W;
    const inv = 1/scale;

    // Far
    cctx.save();
    cctx.globalAlpha = 0.95 + 0.15*lightningBoost;
    cctx.drawImage(
      offFar,
      (-parX*0.25)*scale, (-parY*0.25)*scale,
      offFar.width, offFar.height,
      0,0,W,H
    );
    cctx.restore();

    // Near
    cctx.save();
    cctx.globalAlpha = 1.0;
    cctx.drawImage(
      offNear,
      (-parX*0.55)*scale, (-parY*0.55)*scale,
      offNear.width, offNear.height,
      0,0,W,H
    );
    cctx.restore();

    // Skyline and haze
    drawSkyline(cctx, lightningBoost);

    // Lightning ambient flash (brightens everything)
    if (lightningBoost > 0){
      cctx.save();
      cctx.globalCompositeOperation = 'screen';
      cctx.fillStyle = `rgba(235,245,255,${0.08 + 0.28*lightningBoost})`;
      cctx.fillRect(0,0,W,H);
      cctx.restore();
    }

    /* ---- RAIN ---- */
    rctx.clearRect(0,0,W,H);

    // Slight condensation highlight (cheap)
    const fog = rctx.createRadialGradient(W*0.55, H*0.35, 0, W*0.55, H*0.35, Math.max(W,H)*0.75);
    fog.addColorStop(0, `rgba(255,255,255,${0.05 + 0.06*lightningBoost})`);
    fog.addColorStop(1, `rgba(255,255,255,0)`);
    rctx.fillStyle = fog;
    rctx.fillRect(0,0,W,H);

    // Beads (simple circles)
    rctx.save();
    rctx.globalCompositeOperation = 'screen';
    for (const b of beads){
      b.wob += b.wobs * dt;
      b.y += b.vy * (1.0 + 0.35*lightningBoost);
      b.x += Math.sin(b.wob)*0.25;

      if (b.y > H + 10){
        b.y = rand(-H*0.15, 0);
        b.x = Math.random()*W;
        b.r = rand(1.0, 2.6);
        b.a = rand(0.06, 0.14);
      }

      rctx.fillStyle = `rgba(210,235,255,${b.a + 0.10*lightningBoost})`;
      rctx.beginPath();
      rctx.arc(b.x, b.y, b.r, 0, Math.PI*2);
      rctx.fill();
    }
    rctx.restore();

    // Streaks (fast lines)
    rctx.save();
    rctx.globalCompositeOperation = 'screen';
    const wind = 0.55 + Math.sin(now*0.0022)*0.12;

    for (const d of drops){
      d.y += d.vy * (1.0 + 0.25*lightningBoost) * (dt*60);
      d.x += (d.vx + wind*0.06) * (dt*60) * d.vy*0.16;

      if (d.y - d.len > H + 40 || d.x < -80 || d.x > W + 80){
        d.x = Math.random()*W;
        d.y = rand(-120, 0);
        d.vy = rand(6.0, 12.5);
        d.len = rand(18, 70);
        d.w = rand(1.0, 1.8);
        d.a = rand(0.10, 0.24);
      }

      const x1 = d.x, y1 = d.y;
      const x2 = d.x - d.len*(0.18 + wind*0.02), y2 = d.y - d.len;

      rctx.lineWidth = d.w;
      rctx.strokeStyle = `rgba(220,240,255,${d.a + 0.18*lightningBoost})`;
      rctx.beginPath();
      rctx.moveTo(x2, y2);
      rctx.lineTo(x1, y1);
      rctx.stroke();
    }
    rctx.restore();

    // Very light grain (cheap)
    if (noisePattern){
      rctx.save();
      rctx.globalCompositeOperation = 'overlay';
      rctx.globalAlpha = QUAL.noiseAlpha + 0.03*lightningBoost;
      rctx.fillStyle = noisePattern;
      rctx.translate((now*0.02)%180, (now*0.015)%180);
      rctx.fillRect(-180,-180, W+360, H+360);
      rctx.restore();
    }

    // Lightning flash over glass
    if (lightningBoost > 0){
      rctx.save();
      rctx.globalCompositeOperation = 'screen';
      rctx.fillStyle = `rgba(245,250,255,${0.06 + 0.22*lightningBoost})`;
      rctx.fillRect(0,0,W,H);
      rctx.restore();
    }

    requestAnimationFrame(frame);
  }

  resize();
  requestAnimationFrame(frame);
})();
</script>
</body>
</html>

