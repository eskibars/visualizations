<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Christmas Landscape</title>
  <style>
    html, body {
      margin: 0;
      height: 100%;
      background: #04060f;
      overflow: hidden;
      font-family: system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, sans-serif;
    }
    canvas { display: block; width: 100vw; height: 100vh; }
    .overlay {
      position: fixed;
      inset: 0;
      pointer-events: none;
      background:
        radial-gradient(1200px 700px at 50% 25%, rgba(255,255,255,0.06), transparent 55%),
        radial-gradient(1200px 800px at 50% 65%, transparent 35%, rgba(0,0,0,0.55) 85%),
        linear-gradient(to bottom, rgba(255,255,255,0.04), transparent 30%);
      mix-blend-mode: screen;
    }
    .corner {
      position: fixed;
      left: 18px;
      bottom: 16px;
      color: rgba(255,255,255,0.55);
      font-size: 12px;
      letter-spacing: 0.08em;
      text-transform: uppercase;
      user-select: none;
      pointer-events: none;
      text-shadow: 0 2px 18px rgba(0,0,0,0.65);
    }
    .corner b { color: rgba(255,255,255,0.82); font-weight: 600; }
    @media (prefers-reduced-motion: reduce) {
      .corner::after { content: " · Reduced motion"; }
    }
  </style>
</head>
<body>
  <canvas id="c"></canvas>
  <div class="overlay"></div>
  <div class="corner"><b>Happy Holidays</b> · Winter Night</div>

  <script>
    (() => {
      const canvas = document.getElementById('c');
      const ctx = canvas.getContext('2d', { alpha: false });

      // ---------- Utilities ----------
      const clamp = (v, a, b) => Math.max(a, Math.min(b, v));
      const lerp  = (a, b, t) => a + (b - a) * t;
      const rand  = (a, b) => a + Math.random() * (b - a);
      const easeInOut = t => (t < 0.5) ? 2*t*t : 1 - Math.pow(-2*t + 2, 2)/2;

      const DPR = () => Math.max(1, Math.min(2.5, window.devicePixelRatio || 1)); // cap for TVs

      let W = 0, H = 0, dpr = DPR();
      function resize() {
        dpr = DPR();
        W = Math.floor(window.innerWidth);
        H = Math.floor(window.innerHeight);
        canvas.width  = Math.floor(W * dpr);
        canvas.height = Math.floor(H * dpr);
        ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
        rebuildCaches(); // IMPORTANT: rebuild cached “random” assets at new size
      }
      window.addEventListener('resize', resize, { passive: true });

      const reducedMotion = window.matchMedia && window.matchMedia('(prefers-reduced-motion: reduce)').matches;

      // ---------- Scene Params ----------
      const scene = {
        wind: 0,
        windTarget: 0,
        time: 0,
        snowIntensity: reducedMotion ? 0.55 : 1.0,
        santaChancePerMinute: reducedMotion ? 0.35 : 0.65,
        groundY: () => Math.floor(H * 0.78),
        moon: { x: 0.78, y: 0.22, r: 52 },
      };

      // ---------- Cached “random” assets (to avoid flicker) ----------
      const cache = {
        stars: [],
        hillA: null,
        hillB: null,
        drifts: [],
        sparkles: [],
        moonCraters: [],
        trees: [],
      };

      function genStars() {
        const count = Math.floor((W*H) / 26000);
        cache.stars = Array.from({ length: count }, () => ({
          x: Math.random(),
          y: Math.random() * 0.62,
          r: rand(0.6, 1.8),
          tw: rand(0.6, 1.8),
          ph: rand(0, Math.PI*2),
          a: rand(0.18, 0.9),
        }));
      }

      function genHillProfile({ baseY, segments, amp, seedScale }) {
        // Precompute control points once; animate only with small sinusoidal offset.
        const pts = [];
        for (let i = 0; i <= segments; i++) {
          const xN = i / segments;
          const yJitter = (Math.random() * 2 - 1) * amp;
          const phase = Math.random() * Math.PI * 2;
          const freq = rand(0.6, 1.6) * seedScale;
          pts.push({ xN, yJitter, phase, freq });
        }
        return { baseY, pts };
      }

      function genDrifts() {
        const gy = scene.groundY();
        cache.drifts = Array.from({ length: 7 }, () => ({
          x: Math.random()*W,
          y: gy + rand(10, 90),
          rx: rand(140, 280),
          ry: rand(24, 52),
          rot: rand(-0.1, 0.1),
          a: rand(0.10, 0.20),
        }));
      }

      function genSparkles() {
        // Keep them stable (no per-frame random). Slight shimmer via sin().
        const gy = scene.groundY();
        const n = reducedMotion ? 20 : 60;
        cache.sparkles = Array.from({ length: n }, () => ({
          x: Math.random()*W,
          y: lerp(gy+10, H, Math.random()),
          r: rand(0.6, 1.8),
          ph: rand(0, Math.PI*2),
          a: rand(0.10, 0.22),
        }));
      }

      function genMoonCraters() {
        // Stable crater dots
        const n = 12;
        cache.moonCraters = Array.from({ length: n }, () => {
          const a = Math.random()*Math.PI*2;
          const rr = rand(0.1, 0.9) * scene.moon.r*0.75;
          return {
            a,
            rr,
            r: rand(2.5, 7.5),
            alpha: rand(0.06, 0.14),
          };
        });
      }

      const treeLayers = [
        { count: 26, yN: 0.70, scale: 0.55, alpha: 0.28, jitter: 0.08 },
        { count: 20, yN: 0.74, scale: 0.78, alpha: 0.42, jitter: 0.10 },
        { count: 14, yN: 0.80, scale: 1.05, alpha: 0.62, jitter: 0.12 },
      ];
      function genTrees() {
        const trees = [];
        for (let li=0; li<treeLayers.length; li++) {
          const L = treeLayers[li];
          for (let i=0;i<L.count;i++) {
            trees.push({
              layer: li,
              xN: (i + Math.random()*0.6) / L.count,
              yN: L.yN + rand(-L.jitter, L.jitter),
              s: L.scale * rand(0.75, 1.2),
              w: rand(0.85, 1.15),
              alpha: L.alpha,
            });
          }
        }
        trees.sort((a,b)=>a.yN-b.yN);
        cache.trees = trees;
      }

      function rebuildCaches() {
        genStars();
        cache.hillA = genHillProfile({ baseY: H*0.62, segments: 6, amp: 18, seedScale: 1.0 });
        cache.hillB = genHillProfile({ baseY: H*0.70, segments: 7, amp: 26, seedScale: 1.2 });
        genDrifts();
        genSparkles();
        genMoonCraters();
        genTrees();
        seedSnow();
      }

      // ---------- Snow ----------
      class Snowflake {
        constructor(layer=1) {
          this.layer = layer; // 0 far, 1 mid, 2 near
          this.reset(true);
          this.y = rand(-H, H);
        }
        reset(initial=false) {
          const base = [0.45, 0.85, 1.2][this.layer];
          this.x = Math.random() * W;
          this.y = initial ? Math.random()*H : -rand(10, 120);
          this.r = rand(0.6, 2.6) * base;
          this.vy = rand(18, 68) * base;
          this.vx = rand(-8, 8) * base;
          this.drift = rand(0.6, 2.0) * base;
          this.phase = rand(0, Math.PI*2);
          this.alpha = rand(0.18, 0.85);
          this.spark = rand(0, 1) < 0.08;
        }
        step(dt) {
          const t = scene.time;
          const sway = Math.sin(t * 0.9 + this.phase) * this.drift;
          const wx = scene.wind * (0.35 + this.layer*0.25);
          this.x += (this.vx + sway + wx) * dt;
          this.y += (this.vy * (0.75 + 0.25*scene.snowIntensity)) * dt;
          if (this.y > H + 20) this.reset(false);
          if (this.x < -40) this.x += W + 80;
          if (this.x > W + 40) this.x -= W + 80;
        }
        draw(ctx) {
          const a = this.alpha * (0.55 + 0.45*scene.snowIntensity);
          ctx.globalAlpha = a;

          if (this.layer === 2) {
            ctx.beginPath();
            ctx.fillStyle = 'rgba(255,255,255,0.55)';
            ctx.arc(this.x, this.y, this.r*1.6, 0, Math.PI*2);
            ctx.fill();
          }

          ctx.beginPath();
          ctx.fillStyle = 'rgba(255,255,255,0.92)';
          ctx.arc(this.x, this.y, this.r, 0, Math.PI*2);
          ctx.fill();

          if (this.spark && !reducedMotion) {
            const s = 0.7 + 0.3*Math.sin(scene.time*3.2 + this.phase*2.3);
            ctx.globalAlpha = a * 0.35 * s;
            ctx.beginPath();
            ctx.fillStyle = 'rgba(220,245,255,1)';
            ctx.arc(this.x + this.r*1.2, this.y - this.r*1.0, this.r*0.65, 0, Math.PI*2);
            ctx.fill();
          }
          ctx.globalAlpha = 1;
        }
      }

      const flakes = [];
      function seedSnow() {
        flakes.length = 0;
        const base = Math.floor((W*H) / 6000);
        const count = Math.floor(base * (reducedMotion ? 0.6 : 1.0));
        const far  = Math.floor(count * 0.36);
        const mid  = Math.floor(count * 0.42);
        const near = count - far - mid;
        for (let i=0;i<far;i++) flakes.push(new Snowflake(0));
        for (let i=0;i<mid;i++) flakes.push(new Snowflake(1));
        for (let i=0;i<near;i++) flakes.push(new Snowflake(2));
      }

      // ---------- Santa & Sleigh ----------
      class SantaRun {
        constructor() {
          this.active = true;
          this.dir = Math.random() < 0.5 ? 1 : -1;
          this.yN = rand(0.18, 0.33);
          this.duration = rand(10, 16);
          this.t0 = scene.time;
          this.cloudSkim = rand(0,1) < 0.45;
        }
        draw(ctx) {
          const t = (scene.time - this.t0) / this.duration;
          if (t >= 1) { this.active = false; return; }
          const e = easeInOut(t);
          const x = this.dir === 1 ? lerp(-0.18*W, 1.18*W, e) : lerp(1.18*W, -0.18*W, e);
          const yBase = this.yN * H;
          const bob = Math.sin((scene.time - this.t0) * 3.1) * 4;
          const y = yBase + bob;

          ctx.save();
          ctx.globalAlpha = 0.55;
          ctx.shadowBlur = 18;
          ctx.shadowColor = 'rgba(255,230,160,0.7)';

          const n = 5;
          const spacing = 24;
          for (let i=0;i<n;i++) {
            const rx = x - this.dir*(68 + i*spacing);
            const ry = y + (i%2===0 ? -6 : 4) + Math.sin(scene.time*8 + i)*2;
            drawReindeer(ctx, rx, ry, this.dir);
          }

          ctx.shadowBlur = 0;
          ctx.globalAlpha = 0.45;
          ctx.strokeStyle = 'rgba(255,255,255,0.45)';
          ctx.lineWidth = 1.4;
          ctx.beginPath();
          ctx.moveTo(x - this.dir*68, y - 3);
          ctx.lineTo(x - this.dir*10, y + 6);
          ctx.stroke();

          ctx.globalAlpha = 0.95;
          drawSleigh(ctx, x, y, this.dir);

          if (this.cloudSkim && !reducedMotion) {
            ctx.globalAlpha = 0.22;
            ctx.fillStyle = 'rgba(255,255,255,0.12)';
            for (let i=0;i<3;i++) {
              const p = (scene.time - this.t0) * 0.18 + i*0.8;
              const cx = x + this.dir*(18 + i*22) + Math.sin(p*3)*8;
              const cy = y + 14 + i*6;
              ctx.beginPath();
              ctx.ellipse(cx, cy, 34, 12, 0.25, 0, Math.PI*2);
              ctx.fill();
            }
          }
          ctx.restore();
        }
      }

      function roundRect(ctx, x, y, w, h, r) {
        const rr = Math.min(r, w/2, h/2);
        ctx.beginPath();
        ctx.moveTo(x+rr, y);
        ctx.arcTo(x+w, y, x+w, y+h, rr);
        ctx.arcTo(x+w, y+h, x, y+h, rr);
        ctx.arcTo(x, y+h, x, y, rr);
        ctx.arcTo(x, y, x+w, y, rr);
        ctx.closePath();
      }

      function drawReindeer(ctx, x, y, dir) {
        ctx.save();
        ctx.translate(x, y);
        ctx.scale(dir, 1);

        ctx.fillStyle = 'rgba(90,60,40,0.95)';
        roundRect(ctx, -10, -6, 20, 12, 6); ctx.fill();

        ctx.fillStyle = 'rgba(105,70,50,0.95)';
        roundRect(ctx, 8, -7, 12, 10, 5); ctx.fill();

        ctx.strokeStyle = 'rgba(70,45,30,0.95)';
        ctx.lineWidth = 2;
        const kick = Math.sin(scene.time*10 + x*0.01) * 2.5;
        ctx.beginPath();
        ctx.moveTo(-6, 5); ctx.lineTo(-8, 10 + kick);
        ctx.moveTo(-1, 5); ctx.lineTo(-2, 10 - kick);
        ctx.moveTo(4, 5);  ctx.lineTo(3, 10 + kick*0.7);
        ctx.stroke();

        ctx.strokeStyle = 'rgba(190,170,120,0.8)';
        ctx.lineWidth = 1.2;
        ctx.beginPath();
        ctx.moveTo(14, -7); ctx.lineTo(12, -12);
        ctx.moveTo(12, -12); ctx.lineTo(10, -14);
        ctx.moveTo(12, -12); ctx.lineTo(14, -14);
        ctx.stroke();

        ctx.globalAlpha = 0.85;
        ctx.fillStyle = 'rgba(255,70,70,0.95)';
        ctx.beginPath();
        ctx.arc(20, -2, 2.2, 0, Math.PI*2);
        ctx.fill();

        ctx.restore();
      }

      function drawSleigh(ctx, x, y, dir) {
        ctx.save();
        ctx.translate(x, y);
        ctx.scale(dir, 1);

        ctx.strokeStyle = 'rgba(255,215,120,0.9)';
        ctx.lineWidth = 3.2;
        ctx.lineCap = 'round';
        ctx.beginPath();
        ctx.moveTo(-14, 10); ctx.quadraticCurveTo(-2, 14, 16, 11);
        ctx.quadraticCurveTo(26, 10, 32, 2);
        ctx.stroke();

        ctx.fillStyle = 'rgba(180,30,40,0.95)';
        ctx.beginPath();
        ctx.moveTo(-18, 6);
        ctx.quadraticCurveTo(-22, -2, -12, -8);
        ctx.lineTo(12, -8);
        ctx.quadraticCurveTo(26, -8, 24, 6);
        ctx.closePath();
        ctx.fill();

        ctx.fillStyle = 'rgba(90,20,25,0.85)';
        roundRect(ctx, -8, -16, 16, 10, 4); ctx.fill();

        ctx.fillStyle = 'rgba(160,110,70,0.9)';
        ctx.beginPath();
        ctx.ellipse(6, -20, 10, 7, -0.25, 0, Math.PI*2);
        ctx.fill();

        ctx.globalAlpha = 0.95;
        ctx.fillStyle = 'rgba(60,140,220,0.95)';
        roundRect(ctx, -16, -14, 8, 7, 2); ctx.fill();
        ctx.fillStyle = 'rgba(90,200,120,0.95)';
        roundRect(ctx, -22, -10, 7, 6, 2); ctx.fill();

        ctx.globalAlpha = 0.75;
        ctx.strokeStyle = 'rgba(255,235,210,0.65)';
        ctx.lineWidth = 1.8;
        ctx.beginPath();
        ctx.moveTo(-12, -7);
        ctx.quadraticCurveTo(0, -12, 18, -8);
        ctx.stroke();

        ctx.restore();
      }

      let santa = null;
      let santaTimer = 0;
      function maybeSpawnSanta(dt) {
        if (reducedMotion) return;
        santaTimer += dt;
        if (santaTimer < 2) return;
        santaTimer = 0;

        if (!santa || !santa.active) {
          const pPerSec = (scene.santaChancePerMinute / 60);
          if (Math.random() < pPerSec * 2) santa = new SantaRun();
        }
      }

      // ---------- Foreground: kids + snowman + snowballs ----------
      const kidA = { xN: 0.26, yN: 0.80, phase: rand(0, 9), hue: 200 };
      const kidB = { xN: 0.34, yN: 0.81, phase: rand(0, 9), hue: 330 };
      const snowballs = [];

      function spawnSnowball(fromKid, toX, toY) {
        const x0 = fromKid.xN * W;
        const y0 = fromKid.yN * H;
        const t0 = scene.time;
        const flight = rand(0.75, 1.15);
        snowballs.push({ x0, y0, x1: toX, y1: toY, t0, flight });
      }

      let throwTimer = 0;
      function stepKids(dt) {
        if (reducedMotion) return;
        throwTimer -= dt;
        if (throwTimer <= 0) {
          throwTimer = rand(0.9, 1.8);
          const from = Math.random() < 0.5 ? kidA : kidB;
          const to = (from === kidA) ? kidB : kidA;
          const tx = to.xN * W + rand(-18, 18);
          const ty = to.yN * H - rand(28, 48);
          spawnSnowball(from, tx, ty);
        }
      }

      function drawSnowball(ctx, b) {
        const t = (scene.time - b.t0) / b.flight;
        if (t >= 1) return false;
        const e = easeInOut(t);
        const x = lerp(b.x0, b.x1, e);
        const arc = Math.sin(Math.PI * t) * 95;
        const y = lerp(b.y0, b.y1, e) - arc;

        ctx.save();
        ctx.globalAlpha = 0.9;
        ctx.fillStyle = 'rgba(255,255,255,0.96)';
        ctx.shadowBlur = 10;
        ctx.shadowColor = 'rgba(210,235,255,0.7)';
        ctx.beginPath();
        ctx.arc(x, y, 5.2, 0, Math.PI*2);
        ctx.fill();
        ctx.restore();

        if (t > 0.94) {
          ctx.save();
          ctx.globalAlpha = (1 - t) * 7;
          ctx.fillStyle = 'rgba(255,255,255,0.7)';
          for (let i=0;i<6;i++) {
            const a = i * (Math.PI/3);
            ctx.beginPath();
            ctx.arc(x + Math.cos(a)*10, y + Math.sin(a)*8, 2.2, 0, Math.PI*2);
            ctx.fill();
          }
          ctx.restore();
        }
        return true;
      }

      function drawKid(ctx, kid, facing=1) {
        const x = kid.xN * W;
        const y = kid.yN * H;
        const bounce = Math.sin(scene.time*3 + kid.phase) * 2.5;
        const arm = Math.sin(scene.time*6 + kid.phase) * 0.45;

        ctx.save();
        ctx.translate(x, y + bounce);
        ctx.scale(facing, 1);

        ctx.globalAlpha = 0.28;
        ctx.fillStyle = 'rgba(0,0,0,0.55)';
        ctx.beginPath();
        ctx.ellipse(0, 26, 22, 8, 0, 0, Math.PI*2);
        ctx.fill();
        ctx.globalAlpha = 1;

        ctx.strokeStyle = 'rgba(40,50,70,0.9)';
        ctx.lineWidth = 5;
        ctx.lineCap = 'round';
        ctx.beginPath();
        ctx.moveTo(-6, 18); ctx.lineTo(-8, 28);
        ctx.moveTo(6, 18);  ctx.lineTo(8, 28);
        ctx.stroke();

        ctx.fillStyle = `hsla(${kid.hue}, 65%, 55%, 0.95)`;
        roundRect(ctx, -14, -2, 28, 26, 10); ctx.fill();

        ctx.fillStyle = 'rgba(255,235,220,0.9)';
        roundRect(ctx, -12, -6, 24, 8, 4); ctx.fill();
        ctx.fillStyle = 'rgba(255,120,90,0.7)';
        roundRect(ctx, -6, -2, 12, 4, 2); ctx.fill();

        ctx.fillStyle = 'rgba(255,230,215,0.96)';
        ctx.beginPath();
        ctx.arc(0, -14, 10, 0, Math.PI*2);
        ctx.fill();

        ctx.fillStyle = `hsla(${kid.hue}, 65%, 42%, 0.95)`;
        ctx.beginPath();
        ctx.moveTo(-12, -14);
        ctx.quadraticCurveTo(-2, -30, 12, -16);
        ctx.closePath();
        ctx.fill();
        ctx.fillStyle = 'rgba(255,255,255,0.9)';
        ctx.beginPath();
        ctx.arc(10, -18, 4, 0, Math.PI*2);
        ctx.fill();

        ctx.fillStyle = 'rgba(30,30,40,0.85)';
        ctx.beginPath();
        ctx.arc(-3, -16, 1.2, 0, Math.PI*2);
        ctx.arc(3, -16, 1.2, 0, Math.PI*2);
        ctx.fill();

        ctx.strokeStyle = 'rgba(40,50,70,0.9)';
        ctx.lineWidth = 4.5;
        ctx.beginPath();
        ctx.moveTo(-12, 4); ctx.lineTo(-18, 10 + arm*10);
        ctx.moveTo(12, 4);  ctx.lineTo(18, 10 - arm*10);
        ctx.stroke();

        if (!reducedMotion) {
          const hold = (Math.sin(scene.time*3 + kid.phase) + 1) * 0.5;
          ctx.globalAlpha = 0.35 + 0.45*hold;
          ctx.fillStyle = 'rgba(255,255,255,0.95)';
          ctx.beginPath();
          ctx.arc(18, 10 - arm*10, 3.2, 0, Math.PI*2);
          ctx.fill();
          ctx.globalAlpha = 1;
        }

        ctx.restore();
      }

      function drawSnowman(ctx) {
        const x = 0.58 * W;
        const y = scene.groundY() + 8;

        ctx.save();
        ctx.globalAlpha = 0.20;
        ctx.fillStyle = 'rgba(0,0,0,0.6)';
        ctx.beginPath();
        ctx.ellipse(x, y + 40, 44, 12, 0, 0, Math.PI*2);
        ctx.fill();
        ctx.globalAlpha = 1;

        ctx.fillStyle = 'rgba(255,255,255,0.93)';
        ctx.shadowBlur = 18;
        ctx.shadowColor = 'rgba(210,235,255,0.35)';
        ctx.beginPath(); ctx.arc(x, y + 26, 30, 0, Math.PI*2); ctx.fill();
        ctx.beginPath(); ctx.arc(x, y - 2, 22, 0, Math.PI*2); ctx.fill();
        ctx.beginPath(); ctx.arc(x, y - 26, 16, 0, Math.PI*2); ctx.fill();

        ctx.shadowBlur = 0;
        ctx.fillStyle = 'rgba(40,40,50,0.75)';
        for (let i=0;i<3;i++) {
          ctx.beginPath();
          ctx.arc(x, y - 2 + i*13, 2.2, 0, Math.PI*2);
          ctx.fill();
        }

        ctx.fillStyle = 'rgba(255,140,70,0.95)';
        ctx.beginPath();
        ctx.moveTo(x+2, y - 27);
        ctx.lineTo(x+18, y - 24);
        ctx.lineTo(x+2, y - 21);
        ctx.closePath();
        ctx.fill();

        ctx.fillStyle = 'rgba(30,30,40,0.75)';
        ctx.beginPath();
        ctx.arc(x-5, y - 30, 1.7, 0, Math.PI*2);
        ctx.arc(x+6, y - 30, 1.7, 0, Math.PI*2);
        ctx.fill();

        ctx.strokeStyle = 'rgba(120,85,60,0.9)';
        ctx.lineWidth = 3;
        ctx.lineCap = 'round';
        const wave = reducedMotion ? 0 : Math.sin(scene.time*1.4) * 6;
        ctx.beginPath();
        ctx.moveTo(x-18, y - 2); ctx.lineTo(x-52, y - 12 + wave);
        ctx.moveTo(x+18, y - 2); ctx.lineTo(x+56, y - 6 - wave);
        ctx.stroke();

        ctx.fillStyle = 'rgba(210,70,70,0.9)';
        roundRect(ctx, x-18, y - 18, 36, 9, 4); ctx.fill();
        ctx.fillStyle = 'rgba(220,90,90,0.85)';
        roundRect(ctx, x+4, y - 10, 10, 20, 4); ctx.fill();

        ctx.fillStyle = 'rgba(25,25,35,0.92)';
        roundRect(ctx, x-14, y - 55, 28, 20, 6); ctx.fill();
        ctx.fillStyle = 'rgba(35,35,45,0.95)';
        roundRect(ctx, x-20, y - 38, 40, 7, 6); ctx.fill();
        ctx.fillStyle = 'rgba(210,70,70,0.8)';
        roundRect(ctx, x-14, y - 41, 28, 4, 2); ctx.fill();

        ctx.restore();
      }

      // ---------- Trees ----------
      function drawTree(ctx, x, y, s, alpha) {
        ctx.save();
        ctx.globalAlpha = alpha;
        ctx.translate(x, y);
        ctx.scale(s, s);

        ctx.fillStyle = 'rgba(55,42,32,0.85)';
        roundRect(ctx, -4, 18, 8, 14, 3); ctx.fill();

        const colors = [
          'rgba(12,36,26,0.95)',
          'rgba(16,48,34,0.92)',
          'rgba(18,58,42,0.90)',
        ];
        for (let i=0;i<3;i++) {
          const w = 56 - i*10;
          const h = 30 - i*2;
          const yy = 12 - i*10;

          ctx.fillStyle = colors[i];
          ctx.beginPath();
          ctx.moveTo(0, yy - h*0.55);
          ctx.lineTo(w*0.55, yy + h*0.5);
          ctx.lineTo(-w*0.55, yy + h*0.5);
          ctx.closePath();
          ctx.fill();

          ctx.globalAlpha *= 0.85;
          ctx.fillStyle = 'rgba(255,255,255,0.22)';
          ctx.beginPath();
          ctx.moveTo(0, yy - h*0.55);
          ctx.lineTo(w*0.40, yy + h*0.10);
          ctx.lineTo(-w*0.40, yy + h*0.10);
          ctx.closePath();
          ctx.fill();
          ctx.globalAlpha /= 0.85;
        }

        ctx.restore();
      }

      // ---------- Draw: Sky / Hills / Ground ----------
      function drawSky(ctx) {
        ctx.save();

        const g = ctx.createLinearGradient(0, 0, 0, H);
        g.addColorStop(0, 'rgba(4, 8, 20, 1)');
        g.addColorStop(0.35, 'rgba(7, 16, 36, 1)');
        g.addColorStop(0.78, 'rgba(8, 18, 34, 1)');
        g.addColorStop(1, 'rgba(6, 10, 18, 1)');
        ctx.fillStyle = g;
        ctx.fillRect(0, 0, W, H);

        if (!reducedMotion) {
          ctx.globalAlpha = 0.22;
          ctx.save();
          ctx.translate(0, H*0.08);
          const ag = ctx.createLinearGradient(0, 0, W, 0);
          ag.addColorStop(0, 'rgba(120,255,210,0.0)');
          ag.addColorStop(0.25, 'rgba(120,255,210,0.20)');
          ag.addColorStop(0.55, 'rgba(120,170,255,0.18)');
          ag.addColorStop(0.85, 'rgba(190,120,255,0.12)');
          ag.addColorStop(1, 'rgba(190,120,255,0.0)');
          ctx.fillStyle = ag;

          ctx.beginPath();
          const amp = 26;
          const freq = 2.2;
          ctx.moveTo(0, 70);
          for (let x=0; x<=W; x+=18) {
            const t = scene.time*0.06;
            const y = 70 + Math.sin((x/W)*Math.PI*2*freq + t) * amp
                          + Math.sin((x/W)*Math.PI*2*(freq*0.6) - t*1.2) * (amp*0.55);
            ctx.lineTo(x, y);
          }
          ctx.lineTo(W, 190);
          ctx.lineTo(0, 190);
          ctx.closePath();
          ctx.fill();
          ctx.restore();
          ctx.globalAlpha = 1;
        }

        // stars (stable)
        ctx.save();
        for (const s of cache.stars) {
          const tw = 0.6 + 0.4*Math.sin(scene.time*s.tw + s.ph);
          ctx.globalAlpha = s.a * tw;
          ctx.fillStyle = 'rgba(255,255,255,1)';
          ctx.beginPath();
          ctx.arc(s.x*W, s.y*H, s.r, 0, Math.PI*2);
          ctx.fill();
        }
        ctx.restore();
        ctx.globalAlpha = 1;

        // moon (stable craters)
        const mx = scene.moon.x * W;
        const my = scene.moon.y * H;

        ctx.globalAlpha = 0.50;
        const mg = ctx.createRadialGradient(mx, my, 1, mx, my, scene.moon.r*3.2);
        mg.addColorStop(0, 'rgba(255,255,240,0.38)');
        mg.addColorStop(0.35, 'rgba(210,230,255,0.14)');
        mg.addColorStop(1, 'rgba(210,230,255,0)');
        ctx.fillStyle = mg;
        ctx.beginPath();
        ctx.arc(mx, my, scene.moon.r*3.2, 0, Math.PI*2);
        ctx.fill();

        ctx.globalAlpha = 1;
        ctx.fillStyle = 'rgba(255,250,240,0.96)';
        ctx.beginPath();
        ctx.arc(mx, my, scene.moon.r, 0, Math.PI*2);
        ctx.fill();

        // crater shading (no flicker)
        ctx.fillStyle = 'rgba(70,90,120,1)';
        for (const c of cache.moonCraters) {
          ctx.globalAlpha = c.alpha;
          const cx = mx + Math.cos(c.a)*c.rr;
          const cy = my + Math.sin(c.a)*c.rr*0.8;
          ctx.beginPath();
          ctx.arc(cx, cy, c.r, 0, Math.PI*2);
          ctx.fill();
        }
        ctx.globalAlpha = 1;

        ctx.restore();
      }

      function drawHillFromProfile(profile, fillStyle, animScale) {
        ctx.save();
        ctx.fillStyle = fillStyle;
        ctx.beginPath();
        ctx.moveTo(0, H);
        ctx.lineTo(0, profile.baseY);

        const pts = profile.pts;
        for (let i=0; i<pts.length-1; i++) {
          const a = pts[i];
          const b = pts[i+1];
          const x0 = a.xN * W;
          const x1 = b.xN * W;
          const xm = (x0 + x1) / 2;

          const ya = profile.baseY + a.yJitter + Math.sin(scene.time*0.05 + a.phase) * animScale;
          const yb = profile.baseY + b.yJitter + Math.sin(scene.time*0.05 + b.phase) * animScale;

          ctx.quadraticCurveTo(xm, ya, x1, yb);
        }

        ctx.lineTo(W, H);
        ctx.closePath();
        ctx.fill();
        ctx.restore();
      }

      function drawHills(ctx) {
        // Distant hill
        drawHillFromProfile(
          cache.hillA,
          'rgba(10,18,36,1)',
          reducedMotion ? 0 : 8
        );

        // Mid hill with gradient
        const y1 = cache.hillB.baseY;
        const grad = ctx.createLinearGradient(0, y1-80, 0, H);
        grad.addColorStop(0, 'rgba(12,26,46,1)');
        grad.addColorStop(1, 'rgba(6,10,18,1)');
        drawHillFromProfile(
          cache.hillB,
          grad,
          reducedMotion ? 0 : 12
        );

        // Mist band (no random)
        if (!reducedMotion) {
          ctx.globalAlpha = 0.22;
          ctx.fillStyle = 'rgba(255,255,255,0.08)';
          const my = y1 + 20;
          for (let i=0;i<6;i++) {
            const p = scene.time*0.06 + i*0.9;
            const mx = (i/6)*W + Math.sin(p*2)*50;
            ctx.beginPath();
            ctx.ellipse(mx, my + Math.sin(p*3)*10, 220, 42, 0.1, 0, Math.PI*2);
            ctx.fill();
          }
          ctx.globalAlpha = 1;
        }
      }

      function drawGround(ctx) {
        const gy = scene.groundY();
        ctx.save();

        const g = ctx.createLinearGradient(0, gy-80, 0, H);
        g.addColorStop(0, 'rgba(210,230,255,0.40)');
        g.addColorStop(0.55, 'rgba(160,195,230,0.35)');
        g.addColorStop(1, 'rgba(65,90,120,0.55)');
        ctx.fillStyle = g;
        ctx.beginPath();
        ctx.moveTo(0, gy);
        ctx.quadraticCurveTo(W*0.25, gy-30, W*0.5, gy);
        ctx.quadraticCurveTo(W*0.75, gy+32, W, gy+10);
        ctx.lineTo(W, H);
        ctx.lineTo(0, H);
        ctx.closePath();
        ctx.fill();

        // Stable drifts (no flicker)
        for (const d of cache.drifts) {
          ctx.globalAlpha = d.a;
          ctx.fillStyle = 'rgba(255,255,255,0.38)';
          ctx.beginPath();
          ctx.ellipse(d.x, d.y, d.rx, d.ry, d.rot, 0, Math.PI*2);
          ctx.fill();
        }
        ctx.globalAlpha = 1;

        // Stable sparkle points (with gentle shimmer)
        if (!reducedMotion) {
          ctx.fillStyle = 'rgba(255,255,255,0.30)';
          for (const s of cache.sparkles) {
            const shimmer = 0.7 + 0.3*Math.sin(scene.time*2.2 + s.ph);
            ctx.globalAlpha = s.a * shimmer;
            ctx.beginPath();
            ctx.arc(s.x, s.y, s.r, 0, Math.PI*2);
            ctx.fill();
          }
          ctx.globalAlpha = 1;
        }

        ctx.restore();
      }

      // ---------- Wind ----------
      let windTimer = 0;
      function stepWind(dt) {
        windTimer -= dt;
        if (windTimer <= 0) {
          windTimer = rand(2.8, 5.5);
          scene.windTarget = rand(-18, 22) * (reducedMotion ? 0.35 : 1.0);
        }
        scene.wind = lerp(scene.wind, scene.windTarget, 1 - Math.exp(-dt*0.6));
      }

      // ---------- Init + Loop ----------
      resize(); // triggers cache build
      let last = performance.now();

      function frame(now) {
        const dtRaw = (now - last) / 1000;
        const dt = clamp(dtRaw, 0, 0.05);
        last = now;

        scene.time += dt;
        stepWind(dt);

        // sky -> hills -> trees -> santa -> ground -> foreground -> snow
        drawSky(ctx);
        drawHills(ctx);

        const parallax = [0.10, 0.22, 0.38];
        for (const tr of cache.trees) {
          const px = scene.wind * parallax[tr.layer] * (tr.layer+1) * 0.6;
          const x = tr.xN*W + px;
          const y = tr.yN*H;
          drawTree(ctx, x, y, tr.s*tr.w, tr.alpha);
        }

        maybeSpawnSanta(dt);
        if (santa && santa.active) santa.draw(ctx);

        drawGround(ctx);

        drawSnowman(ctx);
        if (!reducedMotion) stepKids(dt);
        drawKid(ctx, kidA, 1);
        drawKid(ctx, kidB, -1);

        for (let i=snowballs.length-1;i>=0;i--) {
          if (!drawSnowball(ctx, snowballs[i])) snowballs.splice(i, 1);
        }

        for (const f of flakes) f.step(dt);
        for (const layer of [0,1,2]) {
          for (const f of flakes) if (f.layer === layer) f.draw(ctx);
        }

        if (!reducedMotion) {
          ctx.save();
          ctx.globalAlpha = 0.18;
          const gy = scene.groundY();
          const fog = ctx.createLinearGradient(0, gy-40, 0, H);
          fog.addColorStop(0, 'rgba(255,255,255,0)');
          fog.addColorStop(0.55, 'rgba(255,255,255,0.08)');
          fog.addColorStop(1, 'rgba(255,255,255,0.16)');
          ctx.fillStyle = fog;
          ctx.fillRect(0, gy-40, W, H-(gy-40));
          ctx.restore();
        }

        requestAnimationFrame(frame);
      }
      requestAnimationFrame(frame);

      // Small dev controls
      document.addEventListener('keydown', (e) => {
        const k = (e.key || '').toLowerCase();
        if (k === 's') scene.snowIntensity = scene.snowIntensity > 0.8 ? 0.55 : 1.0;
        if (k === 'w') scene.windTarget = rand(-28, 30);
        if (k === 'h') {
          const el = document.querySelector('.corner');
          el.style.display = (el.style.display === 'none') ? '' : 'none';
        }
      });
    })();
  </script>
</body>
</html>

